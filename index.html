<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-SystemTap使用技巧之四" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/31/SystemTap%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B9%8B%E5%9B%9B/" class="article-date">
  <time datetime="2019-10-31T08:31:01.000Z" itemprop="datePublished">2019-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/31/SystemTap%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B9%8B%E5%9B%9B/">SystemTap使用技巧之四</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="https://blog.csdn.net/wangzuxi/article/details/44901285" target="_blank" rel="noopener">https://blog.csdn.net/wangzuxi/article/details/44901285</a></p>
<h2 id="1-查看内核文件中函数的执行流程"><a href="#1-查看内核文件中函数的执行流程" class="headerlink" title="1. 查看内核文件中函数的执行流程"></a>1. 查看内核文件中函数的执行流程</h2><pre><code>前段时间研究了一下Linux内核信号处理流程，记录一下用到的技巧吧。

其实如果不用工具，硬是看代码去分析这个信号处理流程的话，还真的可能搞不定，因为不知道看到的代码是否得到执行，有可能都没有编译进去，所以适当的用工具去分析和调试，真的事半功倍。那信号处理从哪里入手呢，当然从系统调用开始，这就用到[SystemTap使用技巧【一】](http://www.iamlzq.club/2019/10/31/SystemTap使用技巧之一/)中讲的一个技巧，看看signal和kill系统调用在哪个文件：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@jusse ~# stap -l &apos;kernel.function(&quot;sys_signal&quot;)&apos;</span><br><span class="line">kernel.function(&quot;SyS_signal@/build/buildd/linux-lts-trusty-3.13.0/kernel/signal.c:3525&quot;)</span><br><span class="line"></span><br><span class="line">root@jusse ~# stap -l &apos;kernel.function(&quot;sys_kill&quot;)&apos;  </span><br><span class="line">kernel.function(&quot;SyS_kill@/build/buildd/linux-lts-trusty-3.13.0/kernel/signal.c:2909&quot;)</span><br></pre></td></tr></table></figure>

<p>可见这两个系统调用是在kernel/signal.c里面实现的，定位到文件之后，就可以直接看代码了，但我还是想继续从调试入手，因为想到了<a href="http://www.iamlzq.club/2019/10/31/SystemTap使用技巧之二/" target="_blank" rel="noopener">SystemTap使用技巧【二】</a>讲到的一个技巧——跟踪进程的执行流程，内核肯定也可以跟踪代码的执行流程，于是就写了下面的SystemTap脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@jusse ~/systemtap# cat kernel_signal_process.stp </span><br><span class="line">probe begin &#123;</span><br><span class="line">    printf(&quot;begin\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe kernel.function(&quot;*@/build/buildd/linux-lts-trusty-3.13.0/kernel/signal.c&quot;).call &#123;</span><br><span class="line">    if (target() == pid()) &#123;</span><br><span class="line">        printf(&quot;%s -&gt; %s\n&quot;, thread_indent(4), ppfunc())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe kernel.function(&quot;*@/build/buildd/linux-lts-trusty-3.13.0/kernel/signal.c&quot;).return &#123;</span><br><span class="line">    if (target() == pid()) &#123;</span><br><span class="line">        printf(&quot;%s &lt;- %s\n&quot;, thread_indent(-4), ppfunc())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个脚本用到*@，也就是在指定文件中匹配所有函数并打上探测点。那上面这个脚本就比较明了了，就是在signal.c这个文件中所有函数打上call和return两个探测点，call和retrun的时候输出函数名，并利用thread_indent函数增加缩进，这样就可以体现出函数的调用过程了，因为内核处理信号比较频繁，所以上面脚本中就用target()来过滤，只要一个pid的信号处理流程，这样输出比较少才好分析。</p>
<p>先在一个shell中启动SystemTap安装探测点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@jusse ~/systemtap# tty</span><br><span class="line">/dev/pts/32</span><br><span class="line"></span><br><span class="line">root@jusse ~/systemtap# stap -x 26850 ./kernel_signal_process.stp</span><br><span class="line">WARNING: function signals_init is in blacklisted section: keyword at ./kernel_signal_process.stp:5:1</span><br><span class="line"> source: probe kernel.function(&quot;*@/build/buildd/linux-lts-trusty-3.13.0/kernel/signal.c&quot;).call &#123;</span><br><span class="line">         ^</span><br><span class="line">WARNING: function setup_print_fatal_signals is in blacklisted section: keyword at :5:1</span><br><span class="line"> source: probe kernel.function(&quot;*@/build/buildd/linux-lts-trusty-3.13.0/kernel/signal.c&quot;).call &#123;</span><br><span class="line">         ^</span><br><span class="line">begin</span><br></pre></td></tr></table></figure>

<p>接着给一个bash进程发送INT信号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@jusse ~# tty</span><br><span class="line">/dev/pts/33</span><br><span class="line"></span><br><span class="line">root@jusse ~# ps -ef | grep bash</span><br><span class="line">root      9795  9794  0 Feb10 pts/1    00:00:00 /bin/bash</span><br><span class="line">root     26850 26835  0 21:19 pts/32   00:00:00 -bash</span><br><span class="line">root     25439 25424  0 09:53 pts/33   00:00:00 -bash</span><br><span class="line"></span><br><span class="line">root@jusse ~# kill -INT 26850</span><br></pre></td></tr></table></figure>

<p>之后结果如图：</p>
<p><img src="https://img-blog.csdn.net/20150406213255835?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZ3p1eGk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>从这个图中就可以清晰看见信号处理的大概流程，再根据这个流程去对照代码就更容易理解了。至于get_signal_to_deliver这个函数在哪里被调用的，可以在这个函数打个探测点，然后把调用堆栈打出来就知道了，这里就不贴码贴图了。</p>
<h2 id="2-调试内存泄漏以及内存重复释放"><a href="#2-调试内存泄漏以及内存重复释放" class="headerlink" title="2. 调试内存泄漏以及内存重复释放"></a>2. 调试内存泄漏以及内存重复释放</h2><p>我想内存问题肯定困扰过不少人，调用方法也很多，著名的valgrind、efence、mudflap在一定程度上也能帮助我们解决不少问题，但一些情况下它们也无能无力，比如多进程模型上valgrind好像支持得不是很好，efence和mudflap在大型项目中特别是用了其他第三方库的情况下，可能就早早的发现其他库的一些不是问题的问题就退出了，在一些小项目中用还是可以的。那我这里讲的这个技巧就是用SystemTap来查内存泄漏和内存重复释放问题，其原理就是给malloc和free打上探测点，分别计数，最后看看调用malloc和free是不是达到平衡，如果调用malloc多free少，那就可能存在内存泄漏，如果malloc少free多那就可能出现内存重复释放。具体看码吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/*文件名：cc_mem_test.c */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    char *p1;</span><br><span class="line">    char *p2;</span><br><span class="line">    char *p3;</span><br><span class="line">    char *p4;</span><br><span class="line"> </span><br><span class="line">    sleep(20);//让程序sleep 20s是因为我们程序先起来之后，等待SystemTap启动设置探测点</span><br><span class="line"> </span><br><span class="line">    p1 = malloc(500);</span><br><span class="line"> </span><br><span class="line">    p2 = malloc(200);</span><br><span class="line"> </span><br><span class="line">    p3 = malloc(300);</span><br><span class="line"> </span><br><span class="line">    p4 = malloc(300);//泄漏</span><br><span class="line"> </span><br><span class="line">    free(p1);</span><br><span class="line"> </span><br><span class="line">    free(p2);</span><br><span class="line"> </span><br><span class="line">    free(p3);</span><br><span class="line"> </span><br><span class="line">    free(p2);//重复释放</span><br><span class="line"> </span><br><span class="line">    printf(&quot;p1: %p, p2: %p, p3: %p, p4: %p\n&quot;, p1, p2, p3, p4);</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码是一个模拟内存泄漏和内存重复释放的例子，其中p2重复释放，p4没有释放产生泄漏（这个只是例子，因为这个程序运行一下就退出了，malloc的内存即使不释放内核也会帮我们释放的）。</p>
<p>mem.stp：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">probe begin &#123;</span><br><span class="line">    printf(&quot;=============begin============\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//记录内存分配和释放的计数关联数组</span><br><span class="line">global g_mem_ref_tbl</span><br><span class="line">//记录内存分配和释放的调用堆栈关联数组</span><br><span class="line">global g_mem_bt_tbl</span><br><span class="line"></span><br><span class="line">probe process(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;).function(&quot;__libc_malloc&quot;).return, process(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;).function(&quot;__libc_calloc&quot;).return &#123;</span><br><span class="line">    if (target() == pid()) &#123;</span><br><span class="line">        if (g_mem_ref_tbl[$return] == 0) &#123;</span><br><span class="line">            g_mem_ref_tbl[$return]++</span><br><span class="line">            g_mem_bt_tbl[$return] = sprint_ubacktrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe process(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;).function(&quot;__libc_free&quot;).call &#123;</span><br><span class="line">    if (target() == pid()) &#123;</span><br><span class="line">        g_mem_ref_tbl[$mem]--</span><br><span class="line"></span><br><span class="line">        if (g_mem_ref_tbl[$mem] == 0) &#123;</span><br><span class="line">            if ($mem != 0) &#123;</span><br><span class="line">                //记录上次释放的调用堆栈</span><br><span class="line">                g_mem_bt_tbl[$mem] = sprint_ubacktrace()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (g_mem_ref_tbl[$mem] &lt; 0 &amp;&amp; $mem != 0) &#123;</span><br><span class="line">            //如果调用free已经失衡，那就出现了重复释放内存的问题，这里输出当前调用堆栈，以及这个地址上次释放的调用堆栈</span><br><span class="line">            printf(&quot;MMMMMMMMMMMMMMMMMMMMMMMMMMMM\n&quot;)</span><br><span class="line">            printf(&quot;g_mem_ref_tbl[%p]: %d\n&quot;, $mem, g_mem_ref_tbl[$mem])</span><br><span class="line">            print_ubacktrace()</span><br><span class="line">            printf(&quot;last free backtrace:\n%s\n&quot;, g_mem_bt_tbl[$mem])</span><br><span class="line">            printf(&quot;WWWWWWWWWWWWWWWWWWWWWWWWWWWW\n&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe end &#123;</span><br><span class="line">    //最后输出产生泄漏的内存是在哪里分配的</span><br><span class="line">    printf(&quot;=============end============\n&quot;)</span><br><span class="line">    foreach(mem in g_mem_ref_tbl) &#123;</span><br><span class="line">        if (g_mem_ref_tbl[mem] &gt; 0) &#123;</span><br><span class="line">            printf(&quot;%s\n&quot;, g_mem_bt_tbl[mem])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先用两个关联数组全局变量来分别保存内存分配/释放的计数和调用堆栈，在<strong>libc_malloc和</strong>libc_calloc（其实也可以是malloc和calloc）设置return探测点，因为在return的时候就可以通过SystemTap变量$return得到分配的内存地址，并在关联数组g_mem_ref_tbl中以内存地址为key，计数加一。在<strong>libc_free（也可以用free）设置call探测点，</strong>libc_free函数原型是void __libc_free(void *mem);，在call探测点可以通过$mem参数来得到内存地址，然后在关联数组g_mem_ref_tbl中将$mem的计数减一，如果发现计数小于0，那就可以知道有重复释放的问题了，上面的脚本中，当发现重复释放时，就把当前的调用堆栈以及上次释放的调用堆栈打印出来了，这样就很方面定位是在哪里重复释放了，其中保存调用堆栈就用SystemTap的接口sprint_ubacktrace。看一下这个例子的结果：</p>
<p><img src="https://img-blog.csdn.net/20150407003727218?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZ3p1eGk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>可见，红框中0x400655和0x40063d这两个frame就是重复free的地址，黄框0x400621就是产生泄漏的内存分配地址，然后再用addr2line或者objdump反汇编看一下这几个地址就可以确定在哪一行了：</p>
<p><img src="https://img-blog.csdn.net/20150407004917706?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZ3p1eGk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>虽然地址和行号有一些偏差，但往前一个地址基本就是我们要找的调用源，并不太影响我们的分析。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/31/SystemTap%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B9%8B%E5%9B%9B/" data-id="ck2ego8xj0004hgns3hig88g2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SystemTap使用技巧之三" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/31/SystemTap%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B9%8B%E4%B8%89/" class="article-date">
  <time datetime="2019-10-31T08:10:07.000Z" itemprop="datePublished">2019-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/31/SystemTap%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B9%8B%E4%B8%89/">SystemTap使用技巧之三</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>接上篇~</p>
<h3 id="7-14-修改进程中的变量"><a href="#7-14-修改进程中的变量" class="headerlink" title="7.14 修改进程中的变量"></a>7.14 修改进程中的变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">root@j9 ~# cat stap_set_var.c -n     </span><br><span class="line">     1  #include &lt;stdio.h&gt;</span><br><span class="line">     2</span><br><span class="line">     3  typedef struct policy &#123;</span><br><span class="line">     4      int     id;</span><br><span class="line">     5  &#125; policy_t;</span><br><span class="line">     6</span><br><span class="line">     7  int main(int argc, char *argv[])</span><br><span class="line">     8  &#123;</span><br><span class="line">     9      policy_t policy;</span><br><span class="line">    10      policy_t *p = &amp;policy;</span><br><span class="line">    11      policy_t **pp;</span><br><span class="line">    12</span><br><span class="line">    13      p-&gt;id = 111;</span><br><span class="line">    14</span><br><span class="line">    15      printf(&quot;before stap set, p-&gt;id: %d\n&quot;, p-&gt;id);</span><br><span class="line">    16</span><br><span class="line">    17      pp = &amp;p;</span><br><span class="line">    18</span><br><span class="line">    19      printf(&quot;after stap set, p-&gt;id: %d, (*pp)-&gt;id: %d\n&quot;, p-&gt;id, (*pp)-&gt;id);</span><br><span class="line">    20</span><br><span class="line">    21      return 0;</span><br><span class="line">    22  &#125;</span><br><span class="line"></span><br><span class="line">root@j9 ~# gcc -Wall -g -o ./stap_set_var ./stap_set_var.c      </span><br><span class="line"></span><br><span class="line">root@j9 ~# cat stap_set_var.stp</span><br><span class="line">probe process(&quot;./stap_set_var&quot;).statement(&quot;main@./stap_set_var.c:17&quot;)</span><br><span class="line">&#123;</span><br><span class="line">    $p-&gt;id = 222;</span><br><span class="line">    printf(&quot;$p$: %s\n&quot;, $p$)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root@j9 ~# stap -g stap_set_var.stp -c ./stap_set_var         </span><br><span class="line">before stap set, p-&gt;id: 111</span><br><span class="line">after stap set, p-&gt;id: 222, (*pp)-&gt;id: 222</span><br><span class="line">$p$: &#123;.id=222&#125;</span><br><span class="line"></span><br><span class="line">root@j9 ~#</span><br></pre></td></tr></table></figure>

<p>可以看出在第 17 行用 SystemTap 修改后的值在第 19 行就生效了。 需要注意的是 stap 要加-g 参数在 guru 模式下才能修改变量的值。</p>
<h3 id="7-15-跟踪进程执行流程"><a href="#7-15-跟踪进程执行流程" class="headerlink" title="7.15 跟踪进程执行流程"></a>7.15 跟踪进程执行流程</h3><p>thread_indent(n): 补充空格 ppfunc(): 当前探测点所在的函数 在 call 探测点调用 thread_indent(4)补充 4 个空格，在 return 探测点调用 thread_indent(-4)回退 4 个空格，效果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#cat trace_nginx.stp</span><br><span class="line">probe process(&quot;/home/admin/tengine/bin/nginx&quot;).function(&quot;*@src/http/ngx_http_*&quot;).call</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%s -&gt; %s\n&quot;, thread_indent(4), ppfunc());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe process(&quot;/home/admin/tengine/bin/nginx&quot;).function(&quot;*@src/http/ngx_http_*&quot;).return</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%s &lt;- %s\n&quot;, thread_indent(-4), ppfunc());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#stap trace_nginx.stp</span><br><span class="line">     0 nginx(11368):    -&gt; ngx_http_init_connection</span><br><span class="line">    21 nginx(11368):    &lt;- ngx_http_init_connection</span><br><span class="line">     0 nginx(11368):    -&gt; ngx_http_wait_request_handler</span><br><span class="line">    30 nginx(11368):        -&gt; ngx_http_create_request</span><br><span class="line">    41 nginx(11368):        &lt;- ngx_http_create_request</span><br><span class="line">    55 nginx(11368):        -&gt; ngx_http_process_request_line</span><br><span class="line">    72 nginx(11368):            -&gt; ngx_http_read_request_header</span><br><span class="line">    78 nginx(11368):            &lt;- ngx_http_read_request_header</span><br><span class="line">    91 nginx(11368):            -&gt; ngx_http_parse_request_line</span><br><span class="line">    99 nginx(11368):            &lt;- ngx_http_parse_request_line</span><br><span class="line">   109 nginx(11368):            -&gt; ngx_http_process_request_uri</span><br><span class="line">   115 nginx(11368):            &lt;- ngx_http_process_request_uri</span><br><span class="line">   127 nginx(11368):            -&gt; ngx_http_process_request_headers</span><br><span class="line">   138 nginx(11368):                -&gt; ngx_http_read_request_header</span><br><span class="line">   143 nginx(11368):                &lt;- ngx_http_read_request_header</span><br><span class="line">   155 nginx(11368):                -&gt; ngx_http_parse_header_line</span><br><span class="line">   163 nginx(11368):                &lt;- ngx_http_parse_header_line</span><br><span class="line">   178 nginx(11368):                -&gt; ngx_http_process_user_agent</span><br><span class="line">   185 nginx(11368):                &lt;- ngx_http_process_user_agent</span><br><span class="line">   192 nginx(11368):                -&gt; ngx_http_parse_header_line</span><br><span class="line">   198 nginx(11368):                &lt;- ngx_http_parse_header_line</span><br><span class="line">   208 nginx(11368):                -&gt; ngx_http_process_host</span><br><span class="line">   222 nginx(11368):                    -&gt; ngx_http_validate_host</span><br><span class="line">   229 nginx(11368):                    &lt;- ngx_http_validate_host</span><br><span class="line">   239 nginx(11368):                    -&gt; ngx_http_set_virtual_server</span><br><span class="line">   252 nginx(11368):                        -&gt; ngx_http_find_virtual_server</span><br><span class="line">   259 nginx(11368):                        &lt;- ngx_http_find_virtual_server</span><br><span class="line">   263 nginx(11368):                    &lt;- ngx_http_set_virtual_server</span><br><span class="line">   266 nginx(11368):                &lt;- ngx_http_process_host</span><br><span class="line">   274 nginx(11368):                -&gt; ngx_http_parse_header_line</span><br><span class="line">   279 nginx(11368):                &lt;- ngx_http_parse_header_line</span><br><span class="line">   287 nginx(11368):                -&gt; ngx_http_parse_header_line</span><br><span class="line">   292 nginx(11368):                &lt;- ngx_http_parse_header_line</span><br><span class="line"></span><br><span class="line">   .....</span><br><span class="line"></span><br><span class="line">  2072 nginx(11368):                                &lt;- ngx_http_finalize_request</span><br><span class="line">  2076 nginx(11368):                            &lt;- ngx_http_core_content_phase</span><br><span class="line">  2079 nginx(11368):                        &lt;- ngx_http_core_run_phases</span><br><span class="line">  2083 nginx(11368):                    &lt;- ngx_http_handler</span><br><span class="line">  2093 nginx(11368):                    -&gt; ngx_http_run_posted_requests</span><br><span class="line">  2100 nginx(11368):                    &lt;- ngx_http_run_posted_requests</span><br><span class="line">  2103 nginx(11368):                &lt;- ngx_http_process_request</span><br><span class="line">  2107 nginx(11368):            &lt;- ngx_http_process_request_headers</span><br><span class="line">  2111 nginx(11368):        &lt;- ngx_http_process_request_line</span><br><span class="line">  2114 nginx(11368):    &lt;- ngx_http_wait_request_handler</span><br><span class="line">     0 nginx(11368):    -&gt; ngx_http_keepalive_handler</span><br><span class="line">    26 nginx(11368):        -&gt; ngx_http_close_connection</span><br><span class="line">    79 nginx(11368):        &lt;- ngx_http_close_connection</span><br><span class="line">    83 nginx(11368):    &lt;- ngx_http_keepalive_handler</span><br></pre></td></tr></table></figure>

<h3 id="7-16-查看代码执行路径"><a href="#7-16-查看代码执行路径" class="headerlink" title="7.16 查看代码执行路径"></a>7.16 查看代码执行路径</h3><p>pp(): 输出当前被激活的探测点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#cat ngx_http_process_request.stp</span><br><span class="line">probe process(&quot;/home/admin/tengine/bin/nginx&quot;).statement(&quot;ngx_http_process_request@src/http/ngx_http_request.c:*&quot;) &#123;</span><br><span class="line">    printf(&quot;%s\n&quot;, pp())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#stap ngx_http_process_request.stp </span><br><span class="line">process(&quot;/home/admin/tengine/bin/nginx&quot;).statement(&quot;ngx_http_process_request@src/http/ngx_http_request.c:2762&quot;)</span><br><span class="line">process(&quot;/home/admin/tengine/bin/nginx&quot;).statement(&quot;ngx_http_process_request@src/http/ngx_http_request.c:2768&quot;)</span><br><span class="line">process(&quot;/home/admin/tengine/bin/nginx&quot;).statement(&quot;ngx_http_process_request@src/http/ngx_http_request.c:2771&quot;)</span><br><span class="line">process(&quot;/home/admin/tengine/bin/nginx&quot;).statement(&quot;ngx_http_process_request@src/http/ngx_http_request.c:2773&quot;)</span><br><span class="line">process(&quot;/home/admin/tengine/bin/nginx&quot;).statement(&quot;ngx_http_process_request@src/http/ngx_http_request.c:2774&quot;)</span><br><span class="line">process(&quot;/home/admin/tengine/bin/nginx&quot;).statement(&quot;ngx_http_process_request@src/http/ngx_http_request.c:2783&quot;)</span><br><span class="line">process(&quot;/home/admin/tengine/bin/nginx&quot;).statement(&quot;ngx_http_process_request@src/http/ngx_http_request.c:2835&quot;)</span><br><span class="line">process(&quot;/home/admin/tengine/bin/nginx&quot;).statement(&quot;ngx_http_process_request@src/http/ngx_http_request.c:2840&quot;)</span><br><span class="line">process(&quot;/home/admin/tengine/bin/nginx&quot;).statement(&quot;ngx_http_process_request@src/http/ngx_http_request.c:2841&quot;)</span><br><span class="line">process(&quot;/home/admin/tengine/bin/nginx&quot;).statement(&quot;ngx_http_process_request@src/http/ngx_http_request.c:2842&quot;)</span><br><span class="line">process(&quot;/home/admin/tengine/bin/nginx&quot;).statement(&quot;ngx_http_process_request@src/http/ngx_http_request.c:2843&quot;)</span><br><span class="line">process(&quot;/home/admin/tengine/bin/nginx&quot;).statement(&quot;ngx_http_process_request@src/http/ngx_http_request.c:2846&quot;)</span><br><span class="line">process(&quot;/home/admin/tengine/bin/nginx&quot;).statement(&quot;ngx_http_process_request@src/http/ngx_http_request.c:2847&quot;)</span><br><span class="line">process(&quot;/home/admin/tengine/bin/nginx&quot;).statement(&quot;ngx_http_process_request@src/http/ngx_http_request.c:2848&quot;)</span><br><span class="line">process(&quot;/home/admin/tengine/bin/nginx&quot;).statement(&quot;ngx_http_process_request@src/http/ngx_http_request.c:2850&quot;)</span><br><span class="line">process(&quot;/home/admin/tengine/bin/nginx&quot;).statement(&quot;ngx_http_process_request@src/http/ngx_http_request.c:2852&quot;)</span><br><span class="line">process(&quot;/home/admin/tengine/bin/nginx&quot;).statement(&quot;ngx_http_process_request@src/http/ngx_http_request.c:2853&quot;)</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>

<p>可以看出该函数哪些行被执行了。</p>
<h3 id="7-17-巧用正则匹配过滤"><a href="#7-17-巧用正则匹配过滤" class="headerlink" title="7.17 巧用正则匹配过滤"></a>7.17 巧用正则匹配过滤</h3><p>在排查问题时，可以利用一些正则匹配来获取自己想要的信息，比如下面是只收集*.j9.com 的堆栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#cat debug_tengine_5xx.stp </span><br><span class="line">probe process(&quot;/home/admin/tengine/bin/t-coresystem-tengine-cdn&quot;).function(&quot;ngx_http_finalize_request&quot;).call &#123;</span><br><span class="line">    rc = $rc</span><br><span class="line">    if (rc &lt; 0) &#123;</span><br><span class="line">        host = &quot;(null)&quot;</span><br><span class="line">        if ($r-&gt;headers_in-&gt;server-&gt;len != 0) &#123;</span><br><span class="line">            host = user_string_n($r-&gt;headers_in-&gt;server-&gt;data, $r-&gt;headers_in-&gt;server-&gt;len)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cscf = &amp;@cast($r-&gt;srv_conf, &quot;ngx_http_core_srv_conf_t&quot;)[@var(&quot;ngx_http_core_module@src/http/ngx_http_core_module.c&quot;)-&gt;ctx_index]</span><br><span class="line">            if (cscf-&gt;server_name-&gt;len != 0) &#123;</span><br><span class="line">                 host = user_string_n(cscf-&gt;server_name-&gt;data, cscf-&gt;server_name-&gt;len)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (host =~ &quot;.*\.j9\.com&quot;) &#123;</span><br><span class="line">            printf(&quot;rc: %d, host: %s\n&quot;, rc, host)</span><br><span class="line">            print_ubacktrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#stap debug_tengine_5xx.stp</span><br><span class="line">WARNING: Missing unwind data for module, rerun with &apos;stap -d /lib64/libc-2.12.so&apos;</span><br><span class="line">rc: -4, host: www.j9.com</span><br><span class="line"> 0x49af2e : ngx_http_finalize_request+0xe/0x480 [/home/admin/tengine/bin/t-coresystem-tengine-cdn]</span><br><span class="line"> 0x492eab : ngx_http_core_content_phase+0x2b/0x130 [/home/admin/tengine/bin/t-coresystem-tengine-cdn]</span><br><span class="line"> 0x48e74d : ngx_http_core_run_phases+0x3d/0x50 [/home/admin/tengine/bin/t-coresystem-tengine-cdn]</span><br><span class="line"> 0x514c3c : ngx_http_lua_socket_tcp_read+0x44c/0x590 [/home/admin/tengine/bin/t-coresystem-tengine-cdn]</span><br><span class="line"> 0x513150 : ngx_http_lua_socket_tcp_handler+0x30/0x50 [/home/admin/tengine/bin/t-coresystem-tengine-cdn]</span><br><span class="line"> 0x475b96 : ngx_event_process_posted+0x36/0x40 [/home/admin/tengine/bin/t-coresystem-tengine-cdn]</span><br><span class="line"> 0x47d4d8 : ngx_worker_process_cycle+0x138/0x260 [/home/admin/tengine/bin/t-coresystem-tengine-cdn]</span><br><span class="line"> 0x47a38a : ngx_spawn_process+0x1ca/0x5e0 [/home/admin/tengine/bin/t-coresystem-tengine-cdn]</span><br><span class="line"> 0x47c73c : ngx_start_worker_processes+0x7c/0x100 [/home/admin/tengine/bin/t-coresystem-tengine-cdn]</span><br><span class="line"> 0x47db5f : ngx_master_process_cycle+0x3af/0x9b0 [/home/admin/tengine/bin/t-coresystem-tengine-cdn]</span><br><span class="line"> 0x45a740 : main+0xa90/0xb50 [/home/admin/tengine/bin/t-coresystem-tengine-cdn]</span><br><span class="line"> 0x3623e1ecdd [/lib64/libc-2.12.so+0x1ecdd/0x38d000]</span><br><span class="line">rc: -4, host: cdn.j9.com</span><br><span class="line"> 0x49af2e : ngx_http_finalize_request+0xe/0x480 [/home/admin/tengine/bin/t-coresystem-tengine-cdn]</span><br><span class="line"> 0x492eab : ngx_http_core_content_phase+0x2b/0x130 [/home/admin/tengine/bin/t-coresystem-tengine-cdn]</span><br><span class="line"> 0x48e74d : ngx_http_core_run_phases+0x3d/0x50 [/home/admin/tengine/bin/t-coresystem-tengine-cdn]</span><br><span class="line"> 0x514c3c : ngx_http_lua_socket_tcp_read+0x44c/0x590 [/home/admin/tengine/bin/t-coresystem-tengine-cdn]</span><br><span class="line"> 0x513150 : ngx_http_lua_socket_tcp_handler+0x30/0x50 [/home/admin/tengine/bin/t-coresystem-tengine-cdn]</span><br><span class="line"> 0x475b96 : ngx_event_process_posted+0x36/0x40 [/home/admin/tengine/bin/t-coresystem-tengine-cdn]</span><br><span class="line"> 0x47d4d8 : ngx_worker_process_cycle+0x138/0x260 [/home/admin/tengine/bin/t-coresystem-tengine-cdn]</span><br><span class="line"> 0x47a38a : ngx_spawn_process+0x1ca/0x5e0 [/home/admin/tengine/bin/t-coresystem-tengine-cdn]</span><br><span class="line"> 0x47c73c : ngx_start_worker_processes+0x7c/0x100 [/home/admin/tengine/bin/t-coresystem-tengine-cdn]</span><br><span class="line"> 0x47db5f : ngx_master_process_cycle+0x3af/0x9b0 [/home/admin/tengine/bin/t-coresystem-tengine-cdn]</span><br><span class="line"> 0x45a740 : main+0xa90/0xb50 [/home/admin/tengine/bin/t-coresystem-tengine-cdn]</span><br><span class="line"> 0x3623e1ecdd [/lib64/libc-2.12.so+0x1ecdd/0x38d000]</span><br></pre></td></tr></table></figure>

<h3 id="7-18-关联数组用法"><a href="#7-18-关联数组用法" class="headerlink" title="7.18 关联数组用法"></a>7.18 关联数组用法</h3><p>SystemTap 的关联数组必须是全局变量，需要用 global 进行声明，其索引可以支持多达 9 项索引域,各域间以逗号隔开。支持 =, ++ 与 +=操作,其默认的初始值为 0。 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">root@j9 ~# cat stap_array.stp </span><br><span class="line">global reads</span><br><span class="line">probe vfs.read &#123;</span><br><span class="line">    reads[execname(), pid()] ++</span><br><span class="line">&#125;</span><br><span class="line">probe timer.s(3) &#123;</span><br><span class="line">    foreach ([execname, pid] in reads) &#123;</span><br><span class="line">        printf(&quot;%s(%d) : %d \n&quot;, execname, pid, reads[execname, pid])</span><br><span class="line">    &#125;</span><br><span class="line">    print(&quot;============================\n&quot;)</span><br><span class="line">    delete reads</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root@j9 ~# stap stap_array.stp </span><br><span class="line">stapio(18716) : 16 </span><br><span class="line">rsyslogd(770) : 1 </span><br><span class="line">docker(743) : 3 </span><br><span class="line">IFSWatch(5594) : 30 </span><br><span class="line">QThread(5594) : 6 </span><br><span class="line">AliYunDunUpdate(1057) : 4 </span><br><span class="line">sshd(15118) : 1 </span><br><span class="line">sshd(15191) : 1 </span><br><span class="line">============================</span><br><span class="line">stapio(18716) : 16 </span><br><span class="line">sshd(15191) : 3 </span><br><span class="line">docker(743) : 3 </span><br><span class="line">IFSWatch(5594) : 30 </span><br><span class="line">sshd(15118) : 2 </span><br><span class="line">QThread(5594) : 12 </span><br><span class="line">AliYunDunUpdate(1057) : 8 </span><br><span class="line">============================</span><br><span class="line">^C</span><br><span class="line">root@j9 ~/systemtap#</span><br></pre></td></tr></table></figure>

<p>也可以用+、-进行排序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">root@j9 ~# cat stap_array.stp</span><br><span class="line">global reads</span><br><span class="line">probe vfs.read &#123;</span><br><span class="line">    reads[execname(), pid()] ++</span><br><span class="line">&#125;</span><br><span class="line">probe timer.s(3) &#123;</span><br><span class="line">    foreach ([execname, pid+] in reads) &#123;</span><br><span class="line">        printf(&quot;%s(%d) : %d \n&quot;, execname, pid, reads[execname, pid])</span><br><span class="line">    &#125;</span><br><span class="line">    print(&quot;============================\n&quot;)</span><br><span class="line">    delete reads</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root@j9 ~# stap stap_array.stp </span><br><span class="line">docker(743) : 3 </span><br><span class="line">rsyslogd(770) : 1 </span><br><span class="line">AliYunDunUpdate(1057) : 12 </span><br><span class="line">IFSWatch(5594) : 30 </span><br><span class="line">QThread(5594) : 12 </span><br><span class="line">sshd(15118) : 2 </span><br><span class="line">sshd(15191) : 2 </span><br><span class="line">stapio(19021) : 16 </span><br><span class="line">============================</span><br><span class="line">docker(743) : 3 </span><br><span class="line">AliYunDunUpdate(1057) : 12 </span><br><span class="line">IFSWatch(5594) : 30 </span><br><span class="line">QThread(5594) : 6 </span><br><span class="line">sshd(15118) : 1 </span><br><span class="line">sshd(15191) : 19 </span><br><span class="line">stapio(19021) : 16 </span><br><span class="line">============================</span><br><span class="line">^C</span><br><span class="line">root@j9 ~#</span><br></pre></td></tr></table></figure>

<h3 id="7-19-调试内存泄漏以及内存重复释放"><a href="#7-19-调试内存泄漏以及内存重复释放" class="headerlink" title="7.19 调试内存泄漏以及内存重复释放"></a>7.19 调试内存泄漏以及内存重复释放</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">probe begin &#123;</span><br><span class="line">    printf(&quot;=============begin============\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//记录内存分配和释放的计数关联数组</span><br><span class="line">global g_mem_ref_tbl</span><br><span class="line">//记录内存分配和释放的调用堆栈关联数组</span><br><span class="line">global g_mem_bt_tbl</span><br><span class="line"></span><br><span class="line">probe process(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;).function(&quot;__libc_malloc&quot;).return, process(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;).function(&quot;__libc_calloc&quot;).return &#123;</span><br><span class="line">    if (target() == pid()) &#123;</span><br><span class="line">        if (g_mem_ref_tbl[$return] == 0) &#123;</span><br><span class="line">            g_mem_ref_tbl[$return]++</span><br><span class="line">            g_mem_bt_tbl[$return] = sprint_ubacktrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe process(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;).function(&quot;__libc_free&quot;).call &#123;</span><br><span class="line">    if (target() == pid()) &#123;</span><br><span class="line">        g_mem_ref_tbl[$mem]--</span><br><span class="line"></span><br><span class="line">        if (g_mem_ref_tbl[$mem] == 0) &#123;</span><br><span class="line">            if ($mem != 0) &#123;</span><br><span class="line">                //记录上次释放的调用堆栈</span><br><span class="line">                g_mem_bt_tbl[$mem] = sprint_ubacktrace()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (g_mem_ref_tbl[$mem] &lt; 0 &amp;&amp; $mem != 0) &#123;</span><br><span class="line">            //如果调用 free 已经失衡，那就出现了重复释放内存的问题，这里输出当前调用堆栈，以及这个地址上次释放的调用堆栈</span><br><span class="line">            printf(&quot;MMMMMMMMMMMMMMMMMMMMMMMMMMMM\n&quot;)</span><br><span class="line">            printf(&quot;g_mem_ref_tbl[%p]: %d\n&quot;, $mem, g_mem_ref_tbl[$mem])</span><br><span class="line">            print_ubacktrace()</span><br><span class="line">            printf(&quot;last free backtrace:\n%s\n&quot;, g_mem_bt_tbl[$mem])</span><br><span class="line">            printf(&quot;WWWWWWWWWWWWWWWWWWWWWWWWWWWW\n&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe end &#123;</span><br><span class="line">    //最后输出产生泄漏的内存是在哪里分配的</span><br><span class="line">    printf(&quot;=============end============\n&quot;)</span><br><span class="line">    foreach(mem in g_mem_ref_tbl) &#123;</span><br><span class="line">        if (g_mem_ref_tbl[mem] &gt; 0) &#123;</span><br><span class="line">            printf(&quot;%s\n&quot;, g_mem_bt_tbl[mem])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细请看： <a href="http://blog.csdn.net/wangzuxi/article/details/44901285" target="_blank" rel="noopener">http://blog.csdn.net/wangzuxi/article/details/44901285</a></p>
<h3 id="7-20-嵌入-C-代码"><a href="#7-20-嵌入-C-代码" class="headerlink" title="7.20 嵌入 C 代码"></a>7.20 嵌入 C 代码</h3><p>在进程 fork 出子进程时打印出进程 id 和进程名:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">root@jusse ~/systemtap# cat copy_process.stp</span><br><span class="line">function getprocname:string(task:long)</span><br><span class="line">%&#123;</span><br><span class="line">    struct task_struct *task = (struct task_struct *)STAP_ARG_task;</span><br><span class="line">    snprintf(STAP_RETVALUE, MAXSTRINGLEN, &quot;pid: %d, comm: %s&quot;, task-&gt;pid, task-&gt;comm);</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">function getprocid:long(task:long)</span><br><span class="line">%&#123;</span><br><span class="line">    struct task_struct *task = (struct task_struct *)STAP_ARG_task;</span><br><span class="line">    STAP_RETURN(task-&gt;pid);</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">probe kernel.function(&quot;copy_process&quot;).return</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;copy_process return: %p, pid: %d, getprocname: %s, getprocid: %d\n&quot;, $return, $return-&gt;pid, getprocname($return), getprocid($return));</span><br><span class="line">&#125;</span><br><span class="line">root@jusse ~/systemtap# stap -g copy_process.stp</span><br><span class="line">copy_process return: 0xffff880039f61800, pid: 12212, getprocname: pid: 12212, comm: bash, getprocid: 12212</span><br><span class="line">copy_process return: 0xffff880039f61800, pid: 12212, getprocname: pid: 12212, comm: bash, getprocid: 12212</span><br><span class="line">copy_process return: 0xffff880039f63000, pid: 12213, getprocname: pid: 12213, comm: cc_epoll, getprocid: 12213</span><br><span class="line">copy_process return: 0xffff880039f63000, pid: 12213, getprocname: pid: 12213, comm: cc_epoll, getprocid: 12213</span><br><span class="line">copy_process return: 0xffff8800081a9800, pid: 12214, getprocname: pid: 12214, comm: cc_epoll, getprocid: 12214</span><br><span class="line">copy_process return: 0xffff8800081a9800, pid: 12214, getprocname: pid: 12214, comm: cc_epoll, getprocid: 12214</span><br><span class="line">copy_process return: 0xffff8800004d8000, pid: 12215, getprocname: pid: 12215, comm: cc_epoll, getprocid: 12215</span><br><span class="line">copy_process return: 0xffff8800004d8000, pid: 12215, getprocname: pid: 12215, comm: cc_epoll, getprocid: 12215</span><br><span class="line">copy_process return: 0xffff880000564800, pid: 12216, getprocname: pid: 12216, comm: cc_epoll, getprocid: 12216</span><br><span class="line">copy_process return: 0xffff880000564800, pid: 12216, getprocname: pid: 12216, comm: cc_epoll, getprocid: 12216</span><br><span class="line">copy_process return: 0xffff880000566000, pid: 12217, getprocname: pid: 12217, comm: cc_epoll, getprocid: 12217</span><br><span class="line">copy_process return: 0xffff880000566000, pid: 12217, getprocname: pid: 12217, comm: cc_epoll, getprocid: 12217</span><br></pre></td></tr></table></figure>

<p>有三个需要注意的地方： 1 ）、SystemTap 脚本里面嵌入 C 语言代码要在每个大括号前加%前缀，是%{…… %} 而不是%{ …… }%； 2 ）、获取脚本函数参数要用 STAP_ARG_前缀； 3 ）、一般 long 等返回值用 STAP_RETURN，而 string 类型返回值要用 snprintf、strncat 等方式把字符串复制到 STAP_RETVALUE 里面。</p>
<h3 id="7-21-调试内核模块"><a href="#7-21-调试内核模块" class="headerlink" title="7.21 调试内核模块"></a>7.21 调试内核模块</h3><p>这小节就不细讲了，这篇博客 (<a href="http://blog.chinaunix.net/uid-14528823-id-4726046.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-14528823-id-4726046.html</a>) 写得很详细，这里只 copy 两个关键点过来记录一下： 要调试自己的内核模块，需要注意的有两个关键点： 1)、使用 SystemTap 调试内核模块，探测点的编写格式示例为： module(“ext3”).function(“ext3_*”) 2)、需要将自己的模块 cp 到 /lib/modules/uname -r/extra 目录中，否则找不到符号，如果 /lib/modules/uname -r/目录下没有 extra 这个目录，自己 mkdir 一下就可以。</p>
<h3 id="7-22-一些错误提示及解决办法"><a href="#7-22-一些错误提示及解决办法" class="headerlink" title="7.22 一些错误提示及解决办法"></a>7.22 一些错误提示及解决办法</h3><p>错误提示 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR: MAXACTION exceeded near keyword at debug_connection.stp:86:9</span><br><span class="line">ERROR: MAXACTION exceeded near operator &apos;-&gt;&apos; at debug_connection.stp:84:30</span><br></pre></td></tr></table></figure>
<p>解决办法： 加上 stap 参数：-DMAXACTION=102400，如果还报这种类型的错误，只需把 102400 调成更大的值即可。</p>
<p>错误提示 2：</p>
<p><code>WARNING: Number of errors: 0, skipped probes: 82</code><br>解决办法： 加上-DMAXSKIPPED=102400 和-DSTP_NO_OVERLOAD 参数</p>
<p>还有一些可以去掉限制的宏：</p>
<p>MAXSTRINGLEN：这个宏会影响 sprintf 的 buffer 大小，默认为 512 字节。 MAXTRYLOCK：对全局变量进行 try lock 操作的次数，超过则次数还拿不到锁则放弃和跳过该探测点，默认值为 1000.全局变量多的时候可以把这个宏开大一点。</p>
<p>（完）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/31/SystemTap%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B9%8B%E4%B8%89/" data-id="ck2ego8xh0003hgnseqb6goze" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SystemTap使用技巧之二" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/31/SystemTap%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B9%8B%E4%BA%8C/" class="article-date">
  <time datetime="2019-10-31T08:09:55.000Z" itemprop="datePublished">2019-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/31/SystemTap%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B9%8B%E4%BA%8C/">SystemTap使用技巧之二</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>接上一篇内容，本文主要介绍 system tap 使用技巧（下一篇继续讲技巧）</p>
<h2 id="7-技巧"><a href="#7-技巧" class="headerlink" title="7. 技巧"></a>7. 技巧</h2><h3 id="7-1-定位函数位置"><a href="#7-1-定位函数位置" class="headerlink" title="7.1 定位函数位置"></a>7.1 定位函数位置</h3><p>在一个大型项目中找出函数在哪里定义有时很有用，特别是一些比较难找出在哪里定义的函数，比如内核或者 glibc 中的某个函数想要看其实现时，首先得找出其在哪个文件的哪一行定义，用 SystemTap 一行命令就可以搞定。 比如要看 printf 在 glibc 中哪里定义的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@j9 ~# stap -l &apos;process(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;).function(&quot;printf&quot;)&apos; </span><br><span class="line">process(&quot;/lib/x86_64-linux-gnu/libc-2.15.so&quot;).function(&quot;__printf@/build/buildd/eglibc-2.15/stdio-common/printf.c:29&quot;)</span><br></pre></td></tr></table></figure>

<p>可以看出 printf 是在 printf.c 第 29 行定义的。 再比如要看内核中 recv 系统的调用是在哪里定义的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@j9 ~# stap -l &apos;kernel.function(&quot;sys_recv&quot;)&apos;</span><br><span class="line">kernel.function(&quot;sys_recv@/build/buildd/linux-lts-trusty-3.13.0/net/socket.c:1868&quot;)</span><br></pre></td></tr></table></figure>

<p>可以看出 recv 是在 socket.c 第 1868 行定义的。 甚至可以*号来模糊查找：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@j9 ~# stap -l &apos;kernel.function(&quot;*recv&quot;)&apos;   </span><br><span class="line">kernel.function(&quot;__audit_mq_sendrecv@/build/buildd/linux-lts-trusty-3.13.0/kernel/auditsc.c:2062&quot;)</span><br><span class="line">kernel.function(&quot;audit_mq_sendrecv@/build/buildd/linux-lts-trusty-3.13.0/include/linux/audit.h:263&quot;)</span><br><span class="line">kernel.function(&quot;compat_sys_recv@/build/buildd/linux-lts-trusty-3.13.0/net/compat.c:762&quot;)</span><br><span class="line">kernel.function(&quot;i2c_master_recv@/build/buildd/linux-lts-trusty-3.13.0/drivers/i2c/i2c-core.c:1827&quot;)</span><br><span class="line">kernel.function(&quot;ip_cmsg_recv@/build/buildd/linux-lts-trusty-3.13.0/net/ipv4/ip_sockglue.c:147&quot;)</span><br><span class="line">kernel.function(&quot;kgdb_tty_recv@/build/buildd/linux-lts-trusty-3.13.0/drivers/tty/serial/kgdb_nmi.c:109&quot;)</span><br><span class="line">kernel.function(&quot;ppp_do_recv@/build/buildd/linux-lts-trusty-3.13.0/drivers/net/ppp/ppp_generic.c:1617&quot;)</span><br><span class="line">kernel.function(&quot;scm_recv@/build/buildd/linux-lts-trusty-3.13.0/include/net/scm.h:109&quot;)</span><br><span class="line">kernel.function(&quot;sys_recv@/build/buildd/linux-lts-trusty-3.13.0/net/socket.c:1868&quot;)</span><br><span class="line">kernel.function(&quot;tcp_event_data_recv@/build/buildd/linux-lts-trusty-3.13.0/net/ipv4/tcp_input.c:615&quot;)</span><br><span class="line">kernel.function(&quot;tcp_splice_data_recv@/build/buildd/linux-lts-trusty-3.13.0/net/ipv4/tcp.c:637&quot;)</span><br><span class="line">kernel.function(&quot;tpm_tis_recv@/build/buildd/linux-lts-trusty-3.13.0/drivers/char/tpm/tpm_tis.c:231&quot;)</span><br><span class="line">kernel.function(&quot;try_fill_recv@/build/buildd/linux-lts-trusty-3.13.0/drivers/net/virtio_net.c:615&quot;)</span><br></pre></td></tr></table></figure>

<p>同理，也可以用来定位用户进程的函数位置： 比如 tengine 的文件 ngx_shmem.c 里面为了兼容各个操作系统而实现了三个版本的 ngx_shm_alloc，用#if (NGX_HAVE_MAP_ANON)、#elif (NGX_HAVE_MAP_DEVZERO)、#elif (NGX_HAVE_SYSVSHM)、#endif 来做条件编译，那怎么知道编译出来的是哪个版本呢，用 SystemTap 的话就很简单了，否则要去 grep 一下这几宏有没有定义才知道了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@cache4 tengine]# stap -l &apos;process(&quot;/home/admin/tengine/bin/nginx&quot;).function(&quot;ngx_shm_alloc&quot;)&apos;</span><br><span class="line">process(&quot;/home/admin/tengine/bin/nginx&quot;).function(&quot;ngx_shm_alloc@src/os/unix/ngx_shmem.c:15&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="7-2-查看可用探测点以及该探测点上可用的变量"><a href="#7-2-查看可用探测点以及该探测点上可用的变量" class="headerlink" title="7.2 查看可用探测点以及该探测点上可用的变量"></a>7.2 查看可用探测点以及该探测点上可用的变量</h3><p>在一些探测点上能获取的变量比较有限，这是因为这些变量可能已经被编译器优化掉了，优化掉的变量就获取不到了。一般先用-L 参数来看看有哪些变量可以直接使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@cache4 tengine]# stap -L &apos;process(&quot;/home/admin/tengine/bin/nginx&quot;).function(&quot;ngx_shm_alloc&quot;)&apos; </span><br><span class="line">process(&quot;/home/admin/tengine/bin/nginx&quot;).function(&quot;ngx_shm_alloc@src/os/unix/ngx_shmem.c:15&quot;) $shm:ngx_shm_t*</span><br></pre></td></tr></table></figure>

<p>可见在该探测点上可以直接使用$shm 这个变量，其类型是 ngx_shm_t*。 statement 探测点也类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@cache4 tengine]# stap -L &apos;process(&quot;/home/admin/tengine/bin/nginx&quot;).statement(&quot;ngx_pcalloc@src/core/ngx_palloc.c:*&quot;)&apos;                   </span><br><span class="line">process(&quot;/home/admin/tengine/bin/nginx&quot;).statement(&quot;ngx_pcalloc@src/core/ngx_palloc.c:395&quot;) $pool:ngx_pool_t* $size:size_t</span><br><span class="line">process(&quot;/home/admin/tengine/bin/nginx&quot;).statement(&quot;ngx_pcalloc@src/core/ngx_palloc.c:398&quot;) $pool:ngx_pool_t* $size:size_t</span><br><span class="line">process(&quot;/home/admin/tengine/bin/nginx&quot;).statement(&quot;ngx_pcalloc@src/core/ngx_palloc.c:399&quot;) $size:size_t</span><br><span class="line">process(&quot;/home/admin/tengine/bin/nginx&quot;).statement(&quot;ngx_pcalloc@src/core/ngx_palloc.c:404&quot;) $size:size_t $p:void*</span><br></pre></td></tr></table></figure>

<h3 id="7-3-输出调用堆栈"><a href="#7-3-输出调用堆栈" class="headerlink" title="7.3 输出调用堆栈"></a>7.3 输出调用堆栈</h3><p>用户态探测点堆栈：print_ubacktrace()、sprint_ubacktrace() 内核态探测点堆栈：print_backtrace()、sprint_backtrace() 不带 s 和带 s 的区别是前者直接输出，后者是返回堆栈字符串。 这几个函数非常有用，在排查问题时可以根据一些特定条件来过滤函数被执行时是怎么调用进来的，比如排查 tengine 返回 5xx 时的调用堆栈是怎样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#cat debug_tengine_5xx.stp </span><br><span class="line">probe process(&quot;/home/admin/tengine/bin/nginx&quot;).function(&quot;ngx_http_finalize_request&quot;).call &#123;</span><br><span class="line">    if ($rc &gt;= 500) &#123;</span><br><span class="line">        printf(&quot;rc: %d\n&quot;, $rc)</span><br><span class="line">        print_ubacktrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#stap debug_tengine_5xx.stp </span><br><span class="line">rc: 502</span><br><span class="line"> 0x49af2e : ngx_http_finalize_request+0xe/0x480 [/home/admin/tengine/bin/nginx]</span><br><span class="line"> 0x543305 : ngx_http_video_flv_send_rest+0xf5/0x380 [/home/admin/tengine/bin/nginx]</span><br><span class="line"> 0x543187 : ngx_http_video_finalize_request+0x57/0xe0 [/home/admin/tengine/bin/nginx]</span><br><span class="line"> 0x49828f : ngx_http_terminate_request+0x4f/0xc0 [/home/admin/tengine/bin/nginx]</span><br><span class="line"> 0x49b760 : ngx_http_test_reading+0x50/0x130 [/home/admin/tengine/bin/nginx]</span><br><span class="line"> 0x49779f : ngx_http_request_handler+0x1f/0x40 [/home/admin/tengine/bin/nginx]</span><br><span class="line"> 0x47ea8f : ngx_epoll_process_events+0x2df/0x330 [/home/admin/tengine/bin/nginx]</span><br><span class="line"> 0x4753f9 : ngx_process_events_and_timers+0x69/0x1c0 [/home/admin/tengine/bin/nginx]</span><br><span class="line"> 0x47d4d8 : ngx_worker_process_cycle+0x138/0x260 [/home/admin/tengine/bin/nginx]</span><br><span class="line"> 0x47a38a : ngx_spawn_process+0x1ca/0x5e0 [/home/admin/tengine/bin/nginx]</span><br><span class="line"> 0x47c73c : ngx_start_worker_processes+0x7c/0x100 [/home/admin/tengine/bin/nginx]</span><br><span class="line"> 0x47db5f : ngx_master_process_cycle+0x3af/0x9b0 [/home/admin/tengine/bin/nginx]</span><br><span class="line"> 0x45a740 : main+0xa90/0xb50 [/home/admin/tengine/bin/nginx]</span><br><span class="line"> 0x3623e1ecdd [/lib64/libc-2.12.so+0x1ecdd/0x38d000]</span><br></pre></td></tr></table></figure>

<p>比如看看内核是怎么收包的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@jusse ~# cat netif_receive_skb.stp </span><br><span class="line">probe kernel.function(&quot;netif_receive_skb&quot;) </span><br><span class="line">&#123; </span><br><span class="line">    printf(&quot;--------------------------------------------------------\n&quot;); </span><br><span class="line">    print_backtrace(); </span><br><span class="line">    printf(&quot;--------------------------------------------------------\n&quot;); </span><br><span class="line">&#125; </span><br><span class="line">root@jusse ~# stap netif_receive_skb.stp</span><br><span class="line">--------------------------------------------------------</span><br><span class="line"> 0xffffffff8164dc00 : netif_receive_skb+0x0/0x90 [kernel]</span><br><span class="line"> 0xffffffff8164e280 : napi_gro_receive+0xb0/0x130 [kernel]</span><br><span class="line"> 0xffffffff81554537 : handle_incoming_queue+0xe7/0x100 [kernel]</span><br><span class="line"> 0xffffffff815555d9 : xennet_poll+0x279/0x430 [kernel]</span><br><span class="line"> 0xffffffff8164ee09 : net_rx_action+0x139/0x250 [kernel]</span><br><span class="line"> 0xffffffff810702cd : __do_softirq+0xdd/0x300 [kernel]</span><br><span class="line"> 0xffffffff8107088e : irq_exit+0x11e/0x140 [kernel]</span><br><span class="line"> 0xffffffff8144e785 : xen_evtchn_do_upcall+0x35/0x50 [kernel]</span><br><span class="line"> 0xffffffff8176c9ed : xen_hvm_callback_vector+0x6d/0x80 [kernel]</span><br><span class="line">--------------------------------------------------------</span><br></pre></td></tr></table></figure>

<h3 id="7-4-获取函数参数"><a href="#7-4-获取函数参数" class="headerlink" title="7.4 获取函数参数"></a>7.4 获取函数参数</h3><p>一些被编译器优化掉的函数参数用-L 去看的时候没有找到，这样的话在探测点里面也不能直接用$方式获取该参数变量，这时可以使用 SystemTap 提供的<em>_arg 函数接口，</em>是根据类型指定的，比如 pointer_arg 是获取指针类型参数，int_arg 是获取整型参数，类似的还有 long_arg、longlong_arg、uint_arg、ulong_arg、ulonglong_arg、s32_arg、s64_arg、u32_arg、u64_arg：</p>
<p>image</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@j9 ~# stap -L &apos;kernel.function(&quot;sys_open&quot;)&apos; </span><br><span class="line">kernel.function(&quot;SyS_open@/build/buildd/linux-lts-trusty-3.13.0/fs/open.c:1011&quot;) $ret:long int</span><br><span class="line">root@j9 ~# cat sys_open.stp </span><br><span class="line">probe kernel.function(&quot;sys_open&quot;).call</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;filename: %p(%s), flags: %d, mode: %x\n&quot;, pointer_arg(1), kernel_string(pointer_arg(1)), int_arg(2), int_arg(3));</span><br><span class="line">&#125;</span><br><span class="line">root@j9 ~# stap sys_open.stp </span><br><span class="line">filename: 0xc2081d2120(/proc/stat), flags: 524288, mode: 0</span><br><span class="line">filename: 0x7facec00e838(/root/opt/libexec/systemtap/stapio), flags: 0, mode: 1b6</span><br><span class="line">filename: 0x2219488(/var/log/auth.log), flags: 0, mode: 1b6</span><br><span class="line">filename: 0x7facec00e838(/root/opt/libexec/systemtap/stapio), flags: 0, mode: 1b6</span><br><span class="line">filename: 0x7fad10172c29(/etc/passwd), flags: 524288, mode: 1b6</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>

<p>再比如两个函数的函数参数类型兼容也可以使用这种方法获取： image</p>
<p>这两个函数的参数完全兼容，只是第二个参数命名不一样而已，可以像下面这么用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#cat debug_tengine_5xx.stp </span><br><span class="line">probe process(&quot;/home/admin/tengine/bin/nginx&quot;).function(&quot;ngx_http_finalize_request&quot;).call, process(&quot;/home/admin/tengine/bin/nginx&quot;).function(&quot;ngx_http_special_response_handler&quot;).call &#123;</span><br><span class="line">    rc = int_arg(2)</span><br><span class="line">    if (rc &gt;= 500) &#123;</span><br><span class="line">        printf(&quot;rc: %d\n&quot;, rc)</span><br><span class="line">        print_ubacktrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-5-获取全局变量"><a href="#7-5-获取全局变量" class="headerlink" title="7.5 获取全局变量"></a>7.5 获取全局变量</h3><p>有时候用$可以直接获取到全局变量，但有时候又获取不到，那可以试试 @var： 比如获取 nginx 的全局变量 ngx_cycyle：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">root@j9 ~# cat get_ngx_cycle.stp</span><br><span class="line">probe process(&quot;/home/admin/tengine/bin/nginx&quot;).function(&quot;ngx_process_events_and_timers&quot;).call &#123;</span><br><span class="line">    printf(&quot;ngx_cycle-&gt;connections: %d\n&quot;, $ngx_cycle-&gt;connections)</span><br><span class="line">    exit()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root@j9 ~# stap get_ngx_cycle.stp</span><br><span class="line">semantic error: while processing probe process(&quot;/home/admin/tengine/bin/nginx&quot;).function(&quot;ngx_process_events_and_timers@src/event/ngx_event.c:225&quot;).call from: process(&quot;/home/admin/tengine/bin/nginx&quot;).function(&quot;ngx_process_events_and_timers&quot;).call</span><br><span class="line"></span><br><span class="line">semantic error: unable to find local &apos;ngx_cycle&apos;, [man error::dwarf] dieoffset 0x73ca8 in /home/admin/tengine/bin/nginx, near pc 0x434152 in ngx_process_events_and_timers src/event/ngx_event.c (alternatives: $cycle, $delta, $timer, $flags)): identifier &apos;$ngx_cycle&apos; at get_ngx_cycle.stp:3:44</span><br><span class="line">        source:     printf(&quot;ngx_cycle-&gt;connections: %d\n&quot;, $ngx_cycle-&gt;connections)</span><br><span class="line">                                                           ^</span><br><span class="line"></span><br><span class="line">Pass 2: analysis failed.  [man error::pass2]</span><br><span class="line"></span><br><span class="line">root@j9 ~# cat get_ngx_cycle.stp</span><br><span class="line">probe process(&quot;/home/admin/tengine/bin/nginx&quot;).function(&quot;ngx_process_events_and_timers&quot;).call &#123;</span><br><span class="line">    ngx_cycle = @var(&quot;ngx_cycle@src/core/ngx_cycle.c&quot;)</span><br><span class="line">    printf(&quot;ngx_cycle-&gt;connections: %d\n&quot;, ngx_cycle-&gt;connections)</span><br><span class="line">    exit()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root@j9 ~# stap get_ngx_cycle.stp</span><br><span class="line">ngx_cycle-&gt;connections: 19507312</span><br></pre></td></tr></table></figure>

<h3 id="7-6-获取数据结构成员用法"><a href="#7-6-获取数据结构成员用法" class="headerlink" title="7.6 获取数据结构成员用法"></a>7.6 获取数据结构成员用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    size_t      len;</span><br><span class="line">    u_char     *data;</span><br><span class="line">&#125; ngx_str_t;</span><br><span class="line"></span><br><span class="line">struct ngx_http_request_s &#123;</span><br><span class="line">    ......</span><br><span class="line">    ngx_uint_t                        method;</span><br><span class="line">    ngx_uint_t                        http_version;</span><br><span class="line"></span><br><span class="line">    ngx_str_t                         request_line;</span><br><span class="line">    ngx_str_t                         raw_uri;</span><br><span class="line">    ngx_str_t                         uri;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面这个是 nginx 里面的 http 请求结构里面的几个成员，在 C 语言里，如果 r 是 struct ngx_http_request_t *，那么要获取 uri 的 data 是这样的：r-&gt;uri.data，但在 SystemTap 里面，不管是指针还是数据结构，都是用-&gt;访问其成员：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#cat get_http_uri.stp</span><br><span class="line">probe process(&quot;/home/admin/tengine/bin/nginx&quot;).function(&quot;ngx_http_process_request&quot;).call &#123;</span><br><span class="line">    printf(&quot;r-&gt;uri.len: %d, r-&gt;uri.data: %p\n&quot;, $r-&gt;uri.len, $r-&gt;uri.data)</span><br><span class="line">&#125;</span><br><span class="line">#stap get_http_uri.stp</span><br><span class="line">WARNING: never-assigned local variable &apos;len&apos; (similar: data): identifier &apos;len&apos; at get_http_uri.stp:2:57</span><br><span class="line"> source:     printf(&quot;r-&gt;uri.len: %d, r-&gt;uri.data: %p\n&quot;, $r-&gt;uri.len, $r-&gt;uri.data)</span><br><span class="line">                                                                 ^</span><br><span class="line">WARNING: never-assigned local variable &apos;data&apos; (similar: len): identifier &apos;data&apos; at :2:70</span><br><span class="line"> source:     printf(&quot;r-&gt;uri.len: %d, r-&gt;uri.data: %p\n&quot;, $r-&gt;uri.len, $r-&gt;uri.data)</span><br><span class="line">                                                                              ^</span><br><span class="line">semantic error: invalid operator: operator &apos;.&apos; at :2:56</span><br><span class="line">        source:     printf(&quot;r-&gt;uri.len: %d, r-&gt;uri.data: %p\n&quot;, $r-&gt;uri.len, $r-&gt;uri.data)</span><br><span class="line">                                                                       ^</span><br><span class="line"></span><br><span class="line">semantic error: type mismatch: expected long but found string: operator &apos;.&apos; at :2:56</span><br><span class="line">        source:     printf(&quot;r-&gt;uri.len: %d, r-&gt;uri.data: %p\n&quot;, $r-&gt;uri.len, $r-&gt;uri.data)</span><br><span class="line">                                                                       ^</span><br><span class="line"></span><br><span class="line">Pass 2: analysis failed.  [man error::pass2]</span><br><span class="line"></span><br><span class="line">#cat get_http_uri.stp</span><br><span class="line">probe process(&quot;/home/admin/tengine/bin/nginx&quot;).function(&quot;ngx_http_process_request&quot;).call &#123;</span><br><span class="line">    printf(&quot;r-&gt;uri.len: %d, r-&gt;uri.data: %p\n&quot;, $r-&gt;uri-&gt;len, $r-&gt;uri-&gt;data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#stap get_http_uri.stp</span><br><span class="line">r-&gt;uri.len: 1, r-&gt;uri.data: 0x1276f94</span><br><span class="line">r-&gt;uri.len: 1, r-&gt;uri.data: 0x11d5fc4</span><br><span class="line">r-&gt;uri.len: 1, r-&gt;uri.data: 0x124fd24</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>

<h3 id="7-7-输出整个数据结构"><a href="#7-7-输出整个数据结构" class="headerlink" title="7.7 输出整个数据结构"></a>7.7 输出整个数据结构</h3><p>SystemTap 有两个语法可以输出整个数据结构：在变量的后面加一个或者两个</p>
<p>$即可，例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#cat get_r_pool.stp</span><br><span class="line">probe process(&quot;/home/admin/tengine/bin/nginx&quot;).function(&quot;ngx_http_process_request&quot;).call &#123;</span><br><span class="line">    printf(&quot;$r-&gt;pool$: %s\n$r-&gt;pool$$: %s\n&quot;, $r-&gt;pool$, $r-&gt;pool$$)</span><br><span class="line">&#125;</span><br><span class="line">#stap get_r_pool.stp</span><br><span class="line">$r-&gt;pool$: &#123;.d=&#123;...&#125;, .max=4016, .current=0x161acd0, .chain=0x0, .large=0x0, .cleanup=0x0, .log=0x161c690&#125;</span><br><span class="line">$r-&gt;pool$$: &#123;.d=&#123;.last=&quot;a&quot;, .end=&quot;&quot;, .next=0x1617650, .failed=0&#125;, .max=4016, .current=0x161acd0, .chain=0x0, .large=0x0, .cleanup=0x0, .log=0x161c690&#125;</span><br></pre></td></tr></table></figure>

<p>其中 r-&gt;pool 的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    u_char               *last;</span><br><span class="line">    u_char               *end;</span><br><span class="line">    ngx_pool_t           *next;</span><br><span class="line">    ngx_uint_t            failed;</span><br><span class="line">&#125; ngx_pool_data_t;</span><br><span class="line"></span><br><span class="line">struct ngx_pool_s &#123;</span><br><span class="line">    ngx_pool_data_t       d;</span><br><span class="line">    size_t                max;</span><br><span class="line">    ngx_pool_t           *current;</span><br><span class="line">    ngx_chain_t          *chain;</span><br><span class="line">    ngx_pool_large_t     *large;</span><br><span class="line">    ngx_pool_cleanup_t   *cleanup;</span><br><span class="line">    ngx_log_t            *log;</span><br><span class="line">#if  (NGX_DEBUG_POOL)</span><br><span class="line">    size_t                size;</span><br><span class="line">    ngx_pool_stat_t      *stat;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ngx_pool_s 包含了结构 ngx_pool_data_t。变量后面加和$的区别是后者展开了里面的结构而前者不展开，此用法只输出基本数据类型的值。</p>
<h3 id="7-8-输出字符串指针"><a href="#7-8-输出字符串指针" class="headerlink" title="7.8 输出字符串指针"></a>7.8 输出字符串指针</h3><p>用户态使用：user_string、user_string_n 内核态使用：kernel_string、kernel_string_n、user_string_quoted</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#cat get_http_uri.stp</span><br><span class="line">probe process(&quot;/home/admin/tengine/bin/nginx&quot;).function(&quot;ngx_http_process_request&quot;).call &#123;</span><br><span class="line">    printf(&quot;r-&gt;uri: %s\nr-&gt;uri(n): %s\n&quot;, user_string($r-&gt;uri-&gt;data), user_string_n($r-&gt;uri-&gt;data, $r-&gt;uri-&gt;len))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#stap get_http_uri.stp</span><br><span class="line">r-&gt;uri: /?id=1 HTTP/1.1</span><br><span class="line">User-Agent</span><br><span class="line">r-&gt;uri(n): /</span><br><span class="line">user_string_quoted 是获取用户态传给内核的字符串，代码中一般有__user 宏标记： image</span><br><span class="line"></span><br><span class="line">#cat sys_open.stp</span><br><span class="line">probe kernel.function(&quot;sys_open&quot;)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;filename: %s\n&quot;, user_string_quoted(pointer_arg(1)));</span><br><span class="line">&#125;</span><br><span class="line">#stap sys_open.stp </span><br><span class="line">filename: &quot;/var/log/auth.log&quot;</span><br><span class="line">filename: &quot;/proc/stat&quot;</span><br><span class="line">filename: &quot;/proc/uptime&quot;</span><br></pre></td></tr></table></figure>

<h3 id="7-9-指针类型转换"><a href="#7-9-指针类型转换" class="headerlink" title="7.9 指针类型转换"></a>7.9 指针类型转换</h3><p>SystemTap 提供 @cast 来实现指针类型转换，比如可以将 void *转成自己需要的类型： image image</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#cat get_c_fd.stp </span><br><span class="line">probe process(&quot;/home/admin/tengine/bin/nginx&quot;).function(&quot;ngx_http_process_request_line&quot;).call &#123;</span><br><span class="line">    printf(&quot;c-&gt;fd: %d\n&quot;, @cast($rev-&gt;data, &quot;ngx_connection_t&quot;)-&gt;fd)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#stap get_c_fd.stp </span><br><span class="line">c-&gt;fd: 3</span><br><span class="line">c-&gt;fd: 28</span><br><span class="line">c-&gt;fd: 30</span><br><span class="line">c-&gt;fd: 32</span><br><span class="line">c-&gt;fd: 34</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>

<h3 id="7-10-定义某个类型的变量"><a href="#7-10-定义某个类型的变量" class="headerlink" title="7.10 定义某个类型的变量"></a>7.10 定义某个类型的变量</h3><p>同样是用 @cast，定义一个变量用来保存其转换后的地址即可，用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#cat get_c.stp </span><br><span class="line">probe process(&quot;/home/admin/tengine/bin/nginx&quot;).function(&quot;ngx_http_process_request_line&quot;).call &#123;</span><br><span class="line">    c = &amp;@cast($rev-&gt;data, &quot;ngx_connection_t&quot;)</span><br><span class="line">    printf(&quot;c-&gt;fd: %d, c-&gt;requests: %d\n&quot;, c-&gt;fd, c-&gt;requests)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#stap get_c.stp </span><br><span class="line">c-&gt;fd: 3, c-&gt;requests: 1</span><br><span class="line">c-&gt;fd: 28, c-&gt;requests: 1</span><br><span class="line">c-&gt;fd: 30, c-&gt;requests: 1</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>

<h3 id="7-11-多级指针用法"><a href="#7-11-多级指针用法" class="headerlink" title="7.11 多级指针用法"></a>7.11 多级指针用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">root@j9 ~# cat cc_multi_pointer.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">struct test &#123;</span><br><span class="line">    int count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;   </span><br><span class="line">    struct test t = &#123;.count = 5566&#125;;</span><br><span class="line">    struct test *pt = &amp;t;</span><br><span class="line">    struct test **ppt = &amp;pt;</span><br><span class="line"></span><br><span class="line">    printf(&quot;t.count: %d, pt-&gt;count: %d, ppt-&gt;count: %d\n&quot;, t.count, pt-&gt;count, (*ppt)-&gt;count);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root@j9 ~# gcc -Wall -g -o cc_multi_pointer ./cc_multi_pointer.c</span><br><span class="line"></span><br><span class="line">root@j9 ~# cat cc_multi_pointer.stp</span><br><span class="line">probe process(&quot;./cc_multi_pointer&quot;).statement(&quot;main@./cc_multi_pointer.c:13&quot;)</span><br><span class="line">&#123;   </span><br><span class="line">    printf(&quot;$t-&gt;count: %d, $pt-&gt;count: %d, $ppt-&gt;count: %d&quot;, $t-&gt;count, $pt-&gt;count, $ppt[0]-&gt;count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root@j9 ~# ./cc_multi_pointer</span><br><span class="line">t.count: 5566, pt-&gt;count: 5566, ppt-&gt;count: 5566</span><br><span class="line"></span><br><span class="line">root@j9 ~# stap ./cc_multi_pointer.stp -c &apos;./cc_multi_pointer&apos;</span><br><span class="line">t.count: 5566, pt-&gt;count: 5566, ppt-&gt;count: 5566</span><br><span class="line">$t-&gt;count: 5566, $pt-&gt;count: 5566, $ppt-&gt;count: 5566</span><br></pre></td></tr></table></figure>

<p>简言之：通过[0]去解引用即可。</p>
<h3 id="7-12-遍历-C-语言数组"><a href="#7-12-遍历-C-语言数组" class="headerlink" title="7.12 遍历 C 语言数组"></a>7.12 遍历 C 语言数组</h3><p>下面是在 nginx 处理请求关闭时遍历请求头的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#cat debug_http_header.stp</span><br><span class="line">probe process(&quot;/home/admin/tengine/bin/nginx&quot;).function(&quot;ngx_http_finalize_request&quot;).call &#123;</span><br><span class="line">    i = 0</span><br><span class="line">    headers_in_part = &amp;$r-&gt;headers_in-&gt;headers-&gt;part</span><br><span class="line">    headers = &amp;@cast(headers_in_part-&gt;elts, &quot;ngx_table_elt_t&quot;)[0]</span><br><span class="line">    while (headers) &#123;</span><br><span class="line">        if (i &gt;= headers_in_part-&gt;nelts) &#123;</span><br><span class="line">            if (!headers_in_part-&gt;next) &#123;</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">            headers_in_part = headers_in_part-&gt;next;</span><br><span class="line">            headers = &amp;@cast(headers_in_part-&gt;elts, &quot;ngx_table_elt_t&quot;)[0]</span><br><span class="line">            i = 0</span><br><span class="line">        &#125;</span><br><span class="line">        h = &amp;@cast(headers, &quot;ngx_table_elt_t&quot;)[i]</span><br><span class="line">        printf(&quot;%s: %s\n&quot;, user_string_n(h-&gt;key-&gt;data, h-&gt;key-&gt;len), user_string_n(h-&gt;value-&gt;data, h-&gt;value-&gt;len))</span><br><span class="line">        i += 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#stap debug_http_header.stp</span><br><span class="line">User-Agent: curl/7.29.0</span><br><span class="line">Host: 127.0.0.1:20090</span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure>

<h3 id="7-13-查看函数指针所指的函数名"><a href="#7-13-查看函数指针所指的函数名" class="headerlink" title="7.13 查看函数指针所指的函数名"></a>7.13 查看函数指针所指的函数名</h3><p>获取一个地址所对应的符号： 用户态：usymname 内核态：symname</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#cat get_c_handler.stp</span><br><span class="line">probe process(&quot;/home/admin/tengine/bin/nginx&quot;).function(&quot;ngx_http_process_request_line&quot;).call &#123;</span><br><span class="line">    c = &amp;@cast($rev-&gt;data, &quot;ngx_connection_t&quot;)</span><br><span class="line">    printf(&quot;c-&gt;read-&gt;handlers: %s, c-&gt;write-&gt;handler: %s\n&quot;, usymname(c-&gt;read-&gt;handler), usymname(c-&gt;write-&gt;handler))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#stap get_c_handler.stp</span><br><span class="line">c-&gt;read-&gt;handlers: ngx_http_process_request_line, c-&gt;write-&gt;handler: ngx_http_empty_handler</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/31/SystemTap%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B9%8B%E4%BA%8C/" data-id="ck2ego8x30000hgns4a59fayd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SystemTap使用技巧之一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/31/SystemTap%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B9%8B%E4%B8%80/" class="article-date">
  <time datetime="2019-10-31T08:06:44.000Z" itemprop="datePublished">2019-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/31/SystemTap%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B9%8B%E4%B8%80/">SystemTap使用技巧之一</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p> SystemTap 是一个 Linux 非常有用的调试（跟踪 /探测）工具，常用于 Linux<br> 内核或者应用程序的信息采集，比如：获取一个函数里面运行时的变<br> 量、调用堆栈，甚至可以直接修改变量的值，对诊断性能或功能问题非<br> 常有帮助。SystemTap 提供非常简单的命令行接口和很简洁的脚本语<br> 言，以及非常丰富的 tapset 和例子。  </p>
<h2 id="2-何时使用"><a href="#2-何时使用" class="headerlink" title="2. 何时使用"></a>2. 何时使用</h2><p>定位（内核）函数位置<br>查看函数被调用时的调用堆栈、局部变量、参数<br>查看函数指针变量实际指的是哪个函数<br>查看代码的执行轨迹（哪些行被执行了）<br>查看内核或者进程的执行流程<br>调试内存泄露或者内存重复释放<br>统计函数调用次数<br>……</p>
<h2 id="3-原理"><a href="#3-原理" class="headerlink" title="3. 原理"></a>3. 原理</h2><p>在网上找了个原理图：</p>
<p>systemtap</p>
<p>SystemTap 的处理流程有 5 个步骤：解析 script 文件(parse)、细化（ elaborate ）、script 文件翻译成 C 语言代码（ translate ）、编译 C 语言代码（生成内核模块）（ build ）、加载内核模块（ run ）</p>
<p>systemtap_phase</p>
<h2 id="4-安装"><a href="#4-安装" class="headerlink" title="4. 安装"></a>4. 安装</h2><p>SystemTap 依赖的 package： elfutils、gcc、kernel-devel、kernel-debuginfo 如果调用用户态进程，还需要该程序有调试符号，否则无法调试。 推荐使用最新稳定版的 SystemTap，目前最新稳定版为：systemtap-2.9.tar.gz</p>
<h2 id="5-入门"><a href="#5-入门" class="headerlink" title="5. 入门"></a>5. 入门</h2><h3 id="5-1-stap-命令"><a href="#5-1-stap-命令" class="headerlink" title="5.1 stap 命令"></a>5.1 stap 命令</h3><pre><code>stap [OPTIONS] FILENAME [ARGUMENTS]
stap [OPTIONS] - [ARGUMENTS]
stap [OPTIONS] – e SCRIPT [ARGUMENTS]</code></pre><p>比较常用和有用的参数：<br>-e SCRIPT               Run given script.<br>-l PROBE                List matching probes.<br>-L PROBE                List matching probes and local variables.<br>-g                      guru mode<br>-D NM=VAL               emit macro definition into generated C code<br>-o FILE                 send script output to file, instead of stdout.<br>-x PID                  sets target() to PID</p>
<p>Hello World:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@j9 ~/stp# cat hello-world.stp</span><br><span class="line">probe begin &#123;</span><br><span class="line">    print(&quot;===Hello World===\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe end &#123;</span><br><span class="line">    print(&quot;===GunLe===\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root@j9 ~/stp# stap hello-world.stp </span><br><span class="line">===Hello World===</span><br><span class="line">^C===GunLe===</span><br><span class="line">root@j9 ~/stp# stap -e &apos;probe begin &#123; printf(&quot;Hello World!\n&quot;) exit() &#125;&apos;   </span><br><span class="line">Hello World!</span><br><span class="line">root@j9 ~/stp#</span><br></pre></td></tr></table></figure>

<h3 id="5-2-staprun-命令"><a href="#5-2-staprun-命令" class="headerlink" title="5.2 staprun 命令"></a>5.2 staprun 命令</h3><pre><code>staprun [OPTIONS] MODULE [MODULE-OPTIONS]</code></pre><p>stap 命令与 staprun 命令的区别在于： stap 命令的操作对象是 stp 文件或 script 命令等，而 staprun 命令的操作对象是编译生成的内核模块。</p>
<h2 id="6-脚本语言"><a href="#6-脚本语言" class="headerlink" title="6. 脚本语言"></a>6. 脚本语言</h2><h3 id="6-1-probe"><a href="#6-1-probe" class="headerlink" title="6.1 probe"></a>6.1 probe</h3><p>“ probe ” &lt;=&gt; “探测”, 是 SystemTap 进行具体地收集数据的关键字。 systemtap_probe</p>
<p>“ probe point ” 是 probe 动作的时机，也称探测点。也就是 probe 程序监视的某事件点，一旦侦测的事件触发了，则 probe 将从此处插入内核或者用户进程中。 “ probe handle ” 是当 probe 插入内核或者用户进程后所做的具体动作。</p>
<p>probe 用法：</p>
<pre><code>probe probe-point { statement }</code></pre><p>在 Hello World 例子中 begin 和 end 就是 probe-point，statement 就是该探测点的处理逻辑，在 Hello World 例子中 statement 只有一行 print，statement 可以是复杂的代码块。 探测点语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">kernel.function(PATTERN)</span><br><span class="line">kernel.function(PATTERN).call</span><br><span class="line">kernel.function(PATTERN).return</span><br><span class="line">kernel.function(PATTERN).return.maxactive(VALUE)</span><br><span class="line">kernel.function(PATTERN).inline</span><br><span class="line">kernel.function(PATTERN).label(LPATTERN)</span><br><span class="line">module(MPATTERN).function(PATTERN)</span><br><span class="line">module(MPATTERN).function(PATTERN).call</span><br><span class="line">module(MPATTERN).function(PATTERN).return.maxactive(VALUE)</span><br><span class="line">module(MPATTERN).function(PATTERN).inline</span><br><span class="line">kernel.statement(PATTERN)</span><br><span class="line">kernel.statement(ADDRESS).absolute</span><br><span class="line">module(MPATTERN).statement(PATTERN)</span><br><span class="line">process(PROCESSPATH).function(PATTERN)</span><br><span class="line">process(PROCESSPATH).function(PATTERN).call</span><br><span class="line">process(PROCESSPATH).function(PATTERN).return</span><br><span class="line">process(PROCESSPATH).function(PATTERN).inline</span><br><span class="line">process(PROCESSPATH).statement(PATTERN)</span><br></pre></td></tr></table></figure>

<p>PATTERN 语法为：</p>
<p><code>func[@file]</code><br><code>func@file:linenumber</code></p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kernel.function(&quot;*init*&quot;)</span><br><span class="line">module(&quot;ext3&quot;).function(&quot;*&quot;)</span><br><span class="line">kernel.statement(&quot;*@kernel/time.c:296&quot;)</span><br><span class="line">process(&quot;/home/admin/tengine/bin/nginx&quot;).function(&quot;ngx_http_process_request&quot;)</span><br></pre></td></tr></table></figure>
<p>在 return 探测点可以用$return 获取该函数的返回值。 inline 函数无法安装.return 探测点，也无法用$return 获取其返回值。</p>
<h3 id="6-2-基本语法"><a href="#6-2-基本语法" class="headerlink" title="6.2 基本语法"></a>6.2 基本语法</h3><p>SystemTap 脚本语法比较简单，与 C 语言类似，只是每一行结尾”;”是可选的。主要语句如下： if/else、while、for/foreach、break/continue、return、next、delete、try/catch 其中： next：主要在 probe 探测点逻辑处理中使用，调用此语句时，立刻从调用函数中退出。不同于 exit()的是，next 只是退出当前的调用函数，而此 SystemTap 并没有终了，但 exit()则会终止 SystemTap。</p>
<h4 id="6-2-1-变量"><a href="#6-2-1-变量" class="headerlink" title="6.2.1 变量"></a>6.2.1 变量</h4><p>不需要明确声明变量类型，脚本语言会根据函数参数等自动判断变量是什么类型的。 局部变量：在声明的 probe 和 block （”{ }“范围内的部分）内有效。 全局变量：用” global “声明的变量，在此 SystemTap 的整个动作过程中都有效。全局变量的声明位置没有具体要求。需要注意的是，全局变量默认有锁保护，使用过多会有性能损失，如果用全局变量保存指针，可能出现指针所指的内容被进程修改，在探测点中拿不到真正的数据。 获取进程中的变量（全局变量、局部变量、参数）直接在变量名前面加$即可（后面会有例子）</p>
<h4 id="6-2-2-注释"><a href="#6-2-2-注释" class="headerlink" title="6.2.2 注释"></a>6.2.2 注释</h4><p># …… ：Shell 语言风格<br>//…… ：C++语言风格<br> /*……*/ ：C 语言风格</p>
<h4 id="6-2-3-操作符"><a href="#6-2-3-操作符" class="headerlink" title="6.2.3 操作符"></a>6.2.3 操作符</h4><p>比较运算符、算数运算符基本上与 C 语言一样，需要特别指出的是： (1)、.操作符：连接两个字符串，类似于 php ； (2)、=<del>和!</del>：正则匹配和正则不匹配；</p>
<h4 id="6-2-4-函数"><a href="#6-2-4-函数" class="headerlink" title="6.2.4 函数"></a>6.2.4 函数</h4><p>函数定义例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function indent:string (delta:long)&#123;</span><br><span class="line">  return _generic_indent(-1, &quot;&quot;,  delta)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _generic_indent (idx, desc, delta)</span><br><span class="line">&#123;</span><br><span class="line">  ts = __indent_timestamp ()</span><br><span class="line">  if (! _indent_counters[idx]) _indent_timestamps[idx] = ts</span><br><span class="line">  depth = _generic_indent_depth(idx, delta)</span><br><span class="line">  return sprintf(&quot;%6d (%d:%d) %s:%-*s&quot;, (ts - _indent_timestamps[idx]), depth, delta, desc, depth, &quot;&quot;)</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">function strlen:long(s:string) %&#123;</span><br><span class="line">    STAP_RETURN(strlen(STAP_ARG_s));</span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure>

<p>官方有很多很有用的函数，详情请参考： <a href="https://sourceware.org/systemtap/tapsets/" target="_blank" rel="noopener">https://sourceware.org/systemtap/tapsets/</a> 以及在本机安装了 SystemTap 之后在目录 /usr/local/share/systemtap/tapset/下也可以看具体函数的实现以及一些奇特的用法。</p>
<p>本文是阿里云 CDN 安防专家金九所写，下次会发布 SystemTap 使用技巧之二，欢迎沟通交流~</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/31/SystemTap%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B9%8B%E4%B8%80/" data-id="ck2ego8xe0002hgnsc9n7a6bn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-GDB高级用法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/31/GDB%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/" class="article-date">
  <time datetime="2019-10-31T01:54:51.000Z" itemprop="datePublished">2019-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/31/GDB%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/">GDB高级用法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-条件断点"><a href="#1-条件断点" class="headerlink" title="1. 条件断点"></a>1. 条件断点</h2><p>用法：<code>break [LOCATION] [thread THREADNUM] [if CONDITION]</code></p>
<p>test.c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\#include &lt;stdio.h&gt; </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">     int i,j;</span><br><span class="line">     for( i = 0; i &lt; 10; ++i)</span><br><span class="line">     &#123;                                                                                                                                                      </span><br><span class="line">         j = i + 1;</span><br><span class="line">         printf(&quot;%d/n&quot;, j);</span><br><span class="line">     &#125;</span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译：<code>gcc -g test.c -o foo</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 1, main () at test.c:5</span><br><span class="line">5	     for( i = 0; i &lt; 10; ++i)</span><br><span class="line">(gdb) b 8 if j == 5</span><br><span class="line">Breakpoint 2 at 0x4004b2: file test.c, line 8.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main () at test.c:8</span><br><span class="line">8	         printf(&quot;%d/n&quot;, j);</span><br><span class="line">(gdb) p j</span><br><span class="line">$1 = 5</span><br><span class="line">(gdb) n</span><br><span class="line">5	     for( i = 0; i &lt; 10; ++i)</span><br><span class="line">(gdb) n</span><br><span class="line">7	         j = i + 1;</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">1/n2/n3/n4/n5/n6/n7/n8/n9/n10/n</span><br><span class="line">Program exited normally.</span><br><span class="line">(gdb) q</span><br><span class="line">[root@bogon learn]#</span><br></pre></td></tr></table></figure>
<p>当j==5的时候，程序就停在那里了。这里值得注意的是，你可以使断点在指定线程中生效。只要带上thread THREADNUM即可。THREADNUM就是通过<br>info threads打印出的线程编号，例如1，2，3.</p>
<h2 id="2-观察点"><a href="#2-观察点" class="headerlink" title="2. 观察点"></a>2. 观察点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) watch j</span><br><span class="line">Hardware watchpoint 2: j</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Hardware watchpoint 2: j</span><br><span class="line"></span><br><span class="line">Old value = 0</span><br><span class="line">New value = 1</span><br><span class="line">main () at test.c:28</span><br><span class="line">28            printf(&quot;%d/n&quot;, j);</span><br></pre></td></tr></table></figure>
<h2 id="3-模糊断点"><a href="#3-模糊断点" class="headerlink" title="3. 模糊断点"></a>3. 模糊断点</h2><p>通过rb命令可以批量指定符合规则的函数断点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) rb ngx_worker_*</span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x000000000044e5d0 in ngx_worker_process_cycle at src/os/unix/ngx_process_cycle.c:848</span><br><span class="line">2       breakpoint     keep y   0x000000000044e2d0 in ngx_worker_process_exit at src/os/unix/ngx_process_cycle.c:1069</span><br><span class="line">3       breakpoint     keep y   0x000000000044dc20 in ngx_worker_process_init at src/os/unix/ngx_process_cycle.c:901</span><br><span class="line">4       breakpoint     keep y   0x00000000004ff8a0 in ngx_http_lua_ngx_worker_count at ../ngx_lua-0.10.13/src/ngx_http_lua_worker.c:83</span><br><span class="line">5       breakpoint     keep y   0x00000000004ff930 in ngx_http_lua_ngx_worker_exiting at ../ngx_lua-0.10.13/src/ngx_http_lua_worker.c:48</span><br><span class="line">6       breakpoint     keep y   0x00000000004ff8f0 in ngx_http_lua_ngx_worker_id at ../ngx_lua-0.10.13/src/ngx_http_lua_worker.c:64</span><br><span class="line">7       breakpoint     keep y   0x00000000004ff8d0 in ngx_http_lua_ngx_worker_pid at ../ngx_lua-0.10.13/src/ngx_http_lua_worker.c:56</span><br><span class="line">8       breakpoint     keep y   0x0000000000540e10 in ngx_stream_lua_ngx_worker_count at ../ngx_stream_lua-0.0.5/src/ngx_stream_lua_worker.c:83</span><br><span class="line">9       breakpoint     keep y   0x0000000000540ea0 in ngx_stream_lua_ngx_worker_exiting at ../ngx_stream_lua-0.0.5/src/ngx_stream_lua_worker.c:48</span><br><span class="line">10      breakpoint     keep y   0x0000000000540e60 in ngx_stream_lua_ngx_worker_id at ../ngx_stream_lua-0.0.5/src/ngx_stream_lua_worker.c:64</span><br><span class="line">11      breakpoint     keep y   0x0000000000540e40 in ngx_stream_lua_ngx_worker_pid at ../ngx_stream_lua-0.0.5/src/ngx_stream_lua_worker.c:56</span><br></pre></td></tr></table></figure>

<h2 id="4-call命令"><a href="#4-call命令" class="headerlink" title="4. call命令"></a>4. call命令</h2><p>call func_name：调用和执行一个函数<br>(gdb) call gen_and_sork(1234, 1, 0)<br>(gdb) call printf(“abcd\n”)<br>abcd<br>$1=4<br>jump：在源程序中的另一点开始运行<br>(gdb)jump line_number</p>
<h2 id="5-反向执行"><a href="#5-反向执行" class="headerlink" title="5. 反向执行"></a>5. 反向执行</h2><p>gdb 有一个超棒的功能叫回退</p>
<p>这里我可以逐行或逐条指令的回退。它通过播放我们记录的寄存器状态来工作</p>
<p><code>reverse-stepi    #回退一条指令</code><br>注意执行这条命令之前需要先执行record命令</p>
<h2 id="6-x查看内存"><a href="#6-x查看内存" class="headerlink" title="6. x查看内存"></a>6. x查看内存</h2><p>语法：<code>x/&lt;n/f/u&gt; &lt;addr&gt;</code><br>n、f、u是可选的参数<br>n是一个正整数，表示需要显示的内存单元的个数，也就是说从当前地址向后显示几个内存单元的内容，一个内存单元的大小由后面的u定义。<br>f 表示显示的格式，参见下面。如果地址所指的是字符串，那么格式可以是s，如果地十是指令地址，那么格式可以是i。<br>u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字 节，g表示八字节。当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。<br><addr>表示一个内存地址。<br>注意：严格区分n和u的关系，n表示单元个数，u表示每个单元的大小。<br>输出格式</p>
<p>一般来说，GDB会根据变量的类型输出变量的值。但你也可以自定义GDB的输出的格式。例如，你想输出一个整数的十六进制，或是二进制来查看这个整型变量的中的位的情况。要做到这样，你可以使用GDB的数据显示格式：</p>
<p>x 按十六进制格式显示变量。<br>d 按十进制格式显示变量。<br>u 按十六进制格式显示无符号整型。<br>o 按八进制格式显示变量。<br>t 按二进制格式显示变量。<br>a 按十六进制格式显示变量。<br>c 按字符格式显示变量。<br>f 按浮点数格式显示变量。</p>
<h2 id="7-跟踪到子进程"><a href="#7-跟踪到子进程" class="headerlink" title="7. 跟踪到子进程"></a>7. 跟踪到子进程</h2><p>(gdb) help set follow-fork-mode<br>Set debugger response to a program call of fork or vfork.<br>A fork or vfork creates a new process.  follow-fork-mode can be:<br>  parent  - the original process is debugged after a fork<br>  child   - the new process is debugged after a fork<br>The unfollowed process will continue to run.<br>By default, the debugger will follow the parent process.</p>
<h2 id="8-多线程调试技巧"><a href="#8-多线程调试技巧" class="headerlink" title="8. 多线程调试技巧"></a>8. 多线程调试技巧</h2><p>(gdb) help set scheduler-locking<br>Set mode for locking scheduler during execution.<br>off  == no locking (threads may preempt at any time)<br>on   == full locking (no thread except the current thread may run)<br>step == scheduler locked during every single-step operation.<br>    In this mode, no other thread may run during a step command.<br>    Other threads may run while stepping over a function call (‘next’).</p>
<h2 id="9-设置打印字符串长度"><a href="#9-设置打印字符串长度" class="headerlink" title="9. 设置打印字符串长度"></a>9. 设置打印字符串长度</h2><h2 id="10-执行外部命令"><a href="#10-执行外部命令" class="headerlink" title="10. 执行外部命令"></a>10. 执行外部命令</h2><p>(gdb) help shell<br>Execute the rest of the line as a shell command.<br>With no arguments, run an inferior shell.</p>
<h2 id="11-gdbinit文件"><a href="#11-gdbinit文件" class="headerlink" title="11. gdbinit文件"></a>11. gdbinit文件</h2><p>GDB在启动时，会在用户主目录中寻找这个文件，并执行该文件中所有命令，文件格式为：<br>define command-alias<br>command<br>end<br>如要给“b main”取一个别名“bm”：<br>define bm<br>b main<br>end<br>此外，还可以给这个别名加上帮助说明性文字，格式为：<br>document bm<br>帮助说明性文字<br>end<br>如，给“bm”别名添加帮助说明性文字：<br>document bm<br>break at main() function<br>end<br>这样，在使用“help bm”时，GDB就会打印出“break at main() function”</p>
<h2 id="12-自定义命令"><a href="#12-自定义命令" class="headerlink" title="12. 自定义命令"></a>12. 自定义命令</h2><p>除了在.gdbinit文件自定义命令外，还可以直接在GDB运行环境定义命令，语法相同</p>
<h2 id="13-定义命令钩子"><a href="#13-定义命令钩子" class="headerlink" title="13. 定义命令钩子"></a>13. 定义命令钩子</h2><p>钩子用来在执行某个命令前或命令后，先执行某个或某些命令。假如想在print命令前显示一段“———-”，则：<br>define hook-print<br>echo ———-\n<br>end<br>注意“hook-”后接的必须是命令全称，不能是缩写。<br>如果想在命令执行完，再执行某个或某些命令，则：<br>#define hookpost-print<br>echo ———-\n<br>end</p>
<h2 id="14-设置变量"><a href="#14-设置变量" class="headerlink" title="14. 设置变量"></a>14. 设置变量</h2><h2 id="15-循环"><a href="#15-循环" class="headerlink" title="15. 循环"></a>15. 循环</h2><p>GDB支持if/else/while/loop_break/loop_continue，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set $x=1</span><br><span class="line">(gdb) while $x==1</span><br><span class="line"> \&gt;p $x</span><br><span class="line"> \&gt;set $x=0</span><br><span class="line"> \&gt;p $x</span><br><span class="line"> \&gt;end</span><br></pre></td></tr></table></figure>
<p>b$8 = 1<br>b$9 = 0</p>
<h2 id="16-gdb脚本文件"><a href="#16-gdb脚本文件" class="headerlink" title="16. gdb脚本文件"></a>16. gdb脚本文件</h2><p>通过gdb的source命令我们可以将需要执行的GDB命令写到一个外部文件xxx.gdb中，实现gdb脚本编程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set $page = testpool-&gt;free.next</span><br><span class="line">while $page != &amp;testpool.shpool-&gt;free</span><br><span class="line">        if $page-&gt;slab &gt;= 15360</span><br><span class="line">		printf&quot;page slab = %d, page=%x\n&quot;, $page-&gt;slab, $page</span><br><span class="line">		set $page = $page-&gt;next</span><br><span class="line">        end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="17-非交互模式"><a href="#17-非交互模式" class="headerlink" title="17. 非交互模式"></a>17. 非交互模式</h2><p>如果程序正在运行，我们想要查看或者修改程序运行中的变量或者内存等，怎么办呢？这时候可以采用非交互模式运行GDB。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/31/GDB%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/" data-id="ck2ego8xb0001hgnsgs82f12a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-问题排查工具介绍之ltrace" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/30/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D%E4%B9%8Bltrace/" class="article-date">
  <time datetime="2019-10-30T10:09:24.000Z" itemprop="datePublished">2019-10-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/30/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D%E4%B9%8Bltrace/">问题排查工具介绍之ltrace</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>简介：</strong></p>
<p>Trace library calls of a given program.</p>
<p>ltrace命令是用来跟踪进程调用库函数的情况。</p>
<p><strong>语法：</strong></p>
<p>Usage: ltrace [option …] [command [arg …]]</p>
<p><strong>常用参数：</strong></p>
<p>  -a, –align=COLUMN  对齐具体某个列的返回值。</p>
<p>  -c                  计算时间和调用，并在程序退出时打印摘要。</p>
<p>  -C, –demangle      解码低级别名称（内核级）为用户级名称。</p>
<p>  -d, –debug         打印调试信息。<br>      –dl            show calls to symbols in dlopened libraries.<br>  -e expr             改变跟踪的事件。</p>
<p>  -f                  跟踪子进程。</p>
<p>  -h, –help          打印帮助信息。</p>
<p>  -i                  打印指令指针，当库调用时。</p>
<p>  -l, –library=FILE  只打印某个库中的调用。</p>
<p>  -L                  不打印库调用。</p>
<p>  -n, –indent=NR     对每个调用级别嵌套以NR个空格进行缩进输出。</p>
<p>  -o, –output=FILE   把输出定向到文件。</p>
<p>  -p PID              附着在值为PID的进程号上进行ltrace。</p>
<p>  -r                  打印相对时间戳。</p>
<p>  -s STRLEN           设置打印的字符串最大长度。</p>
<p>  -S                  显示系统调用。</p>
<p>  -t, -tt, -ttt       打印绝对时间戳。</p>
<p>  -T                  输出每个调用过程的时间开销。</p>
<p>  -u USERNAME         使用某个用户id或组ID来运行命令。</p>
<p>  -V, –version       打印版本信息，然后退出。</p>
<p>  -x NAME             treat the global NAME like a library subroutine.</p>
<p>Report bugs to <a href="mailto:ltrace-devel@lists.alioth.debian.org" target="_blank" rel="noopener">ltrace-devel@lists.alioth.debian.org</a></p>
<p><strong>命令使用实例：</strong></p>
<ol>
<li><p>查看指定进程库函数调用情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@lzq ~]# ltrace -p 44802,44803 -C -i -n 4 -S -t -T</span><br><span class="line">18:16:32 [0x45030a] __errno_location()                                                 = 0x7fa51ea25768 &lt;0.000252&gt;</span><br><span class="line">18:16:32 [0x431852] gettimeofday(0x7fff7ba12670, NULL)                                 = 0 &lt;0.000265&gt;</span><br><span class="line">18:16:32 [0x4290c9] memcpy(0x7b627b, &quot;30&quot;, 2)                                          = 0x7b627b &lt;0.000192&gt;</span><br><span class="line">18:16:32 [0x4290c9] memcpy(0x7b628d, &quot;32&quot;, 2)                                          = 0x7b628d &lt;0.000183&gt;</span><br><span class="line">18:16:32 [0x4487c7] localtime_r(0x7fff7ba125a8, 0x7fff7ba12630, 0x54faaa, 12851, 0)    = 0x7fff7ba12630 &lt;0.000170&gt;</span><br><span class="line">18:16:32 [0x4290c9] memcpy(0x7b5d44, &quot;2019&quot;, 4)                                        = 0x7b5d44 &lt;0.000158&gt;</span><br><span class="line">18:16:32 [0x4290c9] memcpy(0x7b76fd, &quot;32&quot;, 2)                                          = 0x7b76fd &lt;0.000159&gt;</span><br><span class="line">18:16:32 [0x422f4c] memcpy(0x7fff7ba115b0, &quot;2019/10/30 18:16:32&quot;, 19)                  = 0x7fff7ba115b0 &lt;0.000175&gt;</span><br><span class="line">18:16:32 [0x4294d5] memcpy(0x7fff7ba115c5, &quot;info&quot;, 4)                                  = 0x7fff7ba115c5 &lt;0.000154&gt;</span><br><span class="line">18:16:32 [0x448858] memcpy(0x7fff7ba115ec, &quot;Interrupted system call&quot;, 23)              = 0x7fff7ba115ec &lt;0.000153&gt;</span><br><span class="line">18:16:32 [0x4230f5] write(4, &quot;2019/10/30 18:16:32 [info] 44802&quot;..., 85 &lt;unfinished ...&gt;</span><br><span class="line">18:16:32 [0x380aa0e7b0]     SYS_write(4, &quot;2019/10/30 18:16:32 [info] 44802&quot;..., 85)    = 85 &lt;0.000055&gt;</span><br><span class="line">18:16:32 [0x4230f5] &lt;... write resumed&gt; )                                              = 85 &lt;0.000429&gt;</span><br><span class="line">18:16:32 [0x450118] epoll_wait(12, 0xad3370, 512, 0xffffffff, 0 &lt;unfinished ...&gt;</span><br></pre></td></tr></table></figure>
<p>通过这个命令可以查看指定进程库函数调用的具体情况，包括调用时间，消耗时长，指令地址。</p>
</li>
<li><p>以统计的形式查看库函数调用的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@lzq ~]# ltrace -p 44802,44803 -C -i -n 4 -S -t -T -c</span><br><span class="line">^C% time     seconds  usecs/call     calls      function</span><br><span class="line">------ ----------- ----------- --------- --------------------</span><br><span class="line"> 49.93    4.664301     4664301         1 epoll_wait</span><br><span class="line"> 49.93    4.664030     4664030         1 SYS_epoll_wait</span><br><span class="line">  0.11    0.010485         158        66 memcpy</span><br><span class="line">  0.01    0.000510         255         2 localtime_r</span><br><span class="line">  0.00    0.000461         461         1 accept</span><br><span class="line">  0.00    0.000410         205         2 gettimeofday</span><br><span class="line">  0.00    0.000395         197         2 __errno_location</span><br><span class="line">  0.00    0.000230         230         1 write</span><br><span class="line">  0.00    0.000052          52         1 SYS_write</span><br><span class="line">  0.00    0.000037          37         1 SYS_accept</span><br><span class="line">------ ----------- ----------- --------- --------------------</span><br><span class="line">100.00    9.340911                    78 total</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/30/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D%E4%B9%8Bltrace/" data-id="ck2ego8xl0005hgns31qhakzq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/10/31/SystemTap%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B9%8B%E5%9B%9B/">SystemTap使用技巧之四</a>
          </li>
        
          <li>
            <a href="/2019/10/31/SystemTap%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B9%8B%E4%B8%89/">SystemTap使用技巧之三</a>
          </li>
        
          <li>
            <a href="/2019/10/31/SystemTap%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B9%8B%E4%BA%8C/">SystemTap使用技巧之二</a>
          </li>
        
          <li>
            <a href="/2019/10/31/SystemTap%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B9%8B%E4%B8%80/">SystemTap使用技巧之一</a>
          </li>
        
          <li>
            <a href="/2019/10/31/GDB%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/">GDB高级用法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>